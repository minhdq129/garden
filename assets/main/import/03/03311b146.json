[1,["c71Zn78aZBbpJL/HYW1TTr","aet6ihSJZHK7SrhzKIiJpz@f9941","f6SJZOjTJB/JrJeh5xTdF7","20B+043CNHFog39aR9bkZZ@ffea3","9f40zQ0zxPbpBjF1e5+cRN","0bCkdxgatBLr/S+Xr61Rj4@f9941","4bYv6mRupOR5OKM6c48WP1","1brw/JvvpFnIvdrxpFCgMZ","73sDCUeNBNKovj2sDDu+tu@f9941","08sX+6ebNJOK4Rhf0wns58@98739","6fSYB/yIxA8rBd51BRt1Zd@6c48a","20B+043CNHFog39aR9bkZZ@bcb7d","28pTbh4pFEE5543S0n5O0N@e7740","80VBVqsKRGp7d4dZgLrPcb@98739","2bnEFslaNNCZDkOTDpVk9S@98739","acDvIG2D1A4qbjdkv6h7H+@98739","03E/diQb9JNovokTsSzy0a@6c48a","08sX+6ebNJOK4Rhf0wns58@935df","08sX+6ebNJOK4Rhf0wns58@8f8aa","08sX+6ebNJOK4Rhf0wns58@70e06","08sX+6ebNJOK4Rhf0wns58@438fe","08sX+6ebNJOK4Rhf0wns58@c45fa","08sX+6ebNJOK4Rhf0wns58@bef90","08sX+6ebNJOK4Rhf0wns58@eecaf","08sX+6ebNJOK4Rhf0wns58@b663a","08sX+6ebNJOK4Rhf0wns58@d405f","0bCkdxgatBLr/S+Xr61Rj4@6c48a","20B+043CNHFog39aR9bkZZ@41ac8","24pwTaKGdEbY0aXpIMdeCd@6c48a","28pTbh4pFEE5543S0n5O0N@87811","28pTbh4pFEE5543S0n5O0N@01b19","28pTbh4pFEE5543S0n5O0N@4f17a","12hc0+kFBO+roAe5+R69A6@e7740","12hc0+kFBO+roAe5+R69A6@eb219","30fBCdpKpA+opExpfv1f0z@6c48a","b2AKk5hi9MD7PBkvVWHjb8","87w3AZ7aVCypwnooMTZLlq","bcDAvFuIVJPZn96b9iqDc9","e7uZSgqypAxa+v7bPep4RT","cdGKAnCZJBk6HDIA3C88/y","295Ru5h1dKR7oRLmRHFl+O","28pTbh4pFEE5543S0n5O0N@bcc24","acDvIG2D1A4qbjdkv6h7H+@88459","03IdOL+bBHG5ThN8/0BwQe","6bvpRG2jVJXo7DLlPyDC2m","75jDCD9C9DWrnSWhR1Ypvw","ccH2fqfStBaolIws/fblYv@b95d3","d0MqyYBeFAkIi762QNy1/B@b47c0","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","12Y9dMgWdJKJGmTiZyQR9H@2e76e","4ejS+qLjJNQZSJPOgjff4k@6c48a","80VBVqsKRGp7d4dZgLrPcb@a9549","80VBVqsKRGp7d4dZgLrPcb@b4e6b","80VBVqsKRGp7d4dZgLrPcb@9ed87","80VBVqsKRGp7d4dZgLrPcb@438fe","80VBVqsKRGp7d4dZgLrPcb@bef90","73sDCUeNBNKovj2sDDu+tu@6c48a","2bnEFslaNNCZDkOTDpVk9S@935df","2bnEFslaNNCZDkOTDpVk9S@8f8aa","2bnEFslaNNCZDkOTDpVk9S@76e66","2bnEFslaNNCZDkOTDpVk9S@438fe","2bnEFslaNNCZDkOTDpVk9S@bef90","6acQ7NLaBBmr/CP28xC4ZS@287a1","33o0gGO9pPC7ffRbPtw6nY@a05ff","0fPovwCnVI0JEV2zbVIrfK","80g4hRr8dI/ZlgnLjiuomw","acDvIG2D1A4qbjdkv6h7H+@a9549","acDvIG2D1A4qbjdkv6h7H+@5c108","acDvIG2D1A4qbjdkv6h7H+@fd394","acDvIG2D1A4qbjdkv6h7H+@438fe","acDvIG2D1A4qbjdkv6h7H+@c45fa","acDvIG2D1A4qbjdkv6h7H+@bef90","acDvIG2D1A4qbjdkv6h7H+@eecaf","acDvIG2D1A4qbjdkv6h7H+@b663a","acDvIG2D1A4qbjdkv6h7H+@d405f","aet6ihSJZHK7SrhzKIiJpz@6c48a","035FUgKCRChrfKVN0WFNTF@84d36","aek5KiduNEKowQNd/q7GKg@2228c","ccH2fqfStBaolIws/fblYv@9d093","ccH2fqfStBaolIws/fblYv@5f1bd","ebDrlyLcRBbpBl1QOxos+R@99cfd","4ejS+qLjJNQZSJPOgjff4k@f9941","30fBCdpKpA+opExpfv1f0z@f9941","03E/diQb9JNovokTsSzy0a@f9941","24pwTaKGdEbY0aXpIMdeCd@f9941"],["node","_parent","root","asset","_spriteFrame","data","_mesh","value","_effectAsset","targetInfo","_textureSource","_skeleton","_defaultClip","_normalSprite","mainTexture","_cameraComponent","camera","scene","plantPrefab","_envmapHDR","_envmapLDR","_barSprite"],[["cc.Node",["_name","_layer","_id","_active","_objFlags","__editorExtras__","_prefab","_parent","_children","_components","_lpos","_lrot","_euler","_lscale"],-3,4,1,2,9,5,5,5,5],"cc.ImageAsset","cc.SpriteFrame",["cc.UITransform",["node","_contentSize","__prefab","_anchorPoint"],3,1,5,4,5],["cc.Node",["_name","_id","_parent","_lpos","_lrot","_euler","_components","_children","_prefab"],1,1,5,5,5,2,9,4],["cc.PrefabInfo",["fileId","root","asset","nestedPrefabInstanceRoots"],2,1,1,2],["cc.Widget",["_alignFlags","_left","_right","_bottom","node"],-1,1],["cc.Sprite",["_type","_sizeMode","_useGrayscale","node","_spriteFrame","__prefab"],0,1,6,4],"cc.TextureCube",["cc.Prefab",["_name"],2],["cc.Material",["_states","_defines","_name","_props"],0,12],["cc.MeshRenderer",["_name","node","__prefab","_materials","lightmapSettings","_mesh"],2,1,4,3,4,6],["cc.Button",["_transition","_zoomScale","node","clickEvents","_normalSprite"],1,1,9,6],["cc.ClickEvent",["_componentId","handler","customEventData","target"],0,1],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["cc.Label",["_string","_actualFontSize","_fontSize","node","__prefab"],0,1,4],["cc.Camera",["_projection","_orthoHeight","_far","_visibility","_near","_priority","_clearFlags","node","_color"],-4,1,5],["cc.Node",["_name","_children","_components","_prefab"],2,12,9,4],["cc.Node",["_name","_layer","_parent","_components","_prefab","_lpos"],1,1,12,4,5],["cc.SkeletalAnimation",["node","__prefab","_clips","_defaultClip"],3,1,4,3,6],["cc.CompPrefabInfo",["fileId"],2],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.SkinnedMeshRenderer",["node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],3,1,4,3,4,1,6,6],["cc.ModelLightmapSettings",[],3],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.SceneAsset",["_name"],2],["88b43Dzh+dBnLrzmp5945Wu",["node"],3,1],["9ddefGqg0dAVpQkQmCMz4vd",["node"],3,1],["cc.Canvas",["node","_cameraComponent"],3,1,1],["f1b36959pFKfZ6QG9FL2X6r",["node","camera"],3,1,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,12,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5,5],["cc.ShadowsInfo",["_type","_distance","_shadowColor"],1,5],["cc.SkyboxInfo",["_rotationAngle","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",["_enabled","_fogStart","_fogEnd","_fogColor"],0,5],["cc.OctreeInfo",["_enabled"],2],["b9c5214VhNJQ5Ow6JKl8ENE",["node"],3,1],["cc.TargetInfo",["localID"],2],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],2,1,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,6],["cc.DirectionalLight",["_useColorTemperature","_colorTemperature","_illuminanceHDR","node","_color","_staticSettings"],0,1,5,4],["cc.StaticLightSettings",["_castShadow"],2],["734feVQSzdG76tFES30ltsr",["node","renderPlantPrefabs","plantPrefab"],3,1,3,6],["7844eqBZCNIzIv1ZtYRaDYe",["animalPrefab","node","__prefab"],2,1,4],["b9fabrseGpEIa1XQdW+4wLU",["node","__prefab"],3,1,4],["cc.RenderRoot2D",["node","__prefab"],3,1,4],["7865329OKBPiq+nR+pIYnyH",["node","__prefab","statusSpriteFrames"],3,1,4,3],["cc.ProgressBar",["_totalLength","_progress","node","__prefab","_barSprite"],1,1,4,1],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[5,0,1,2,2],[39,0,2],[45,0,1,2,2],[0,0,7,8,6,10,11,12,2],[0,0,7,6,10,2],[4,0,2,7,8,3,4,5,2],[43,0,1,2,3],[42,0,1,2,2],[20,0,2],[3,0,1,1],[0,4,5,7,6,3],[21,0,1,2,3,2],[7,0,1,3,4,3],[0,0,1,7,9,3],[23,1],[24,0,1,2,3],[44,0,1,2,2],[9,0,2],[15,0,1,2,3,4],[12,0,1,2,3,3],[40,0,1,2,2],[11,1,2,3,4,5,1],[13,0,1,3,3],[0,0,1,7,8,9,10,3],[10,2,0,1,3,4],[14,0,2,2],[41,0,1,2,3],[10,0,1,3,3],[14,0,1,2,3],[0,0,8,9,6,2],[0,0,7,9,6,2],[13,0,1,2,3,4],[9,1],[0,0,8,6,10,2],[0,0,8,6,11,12,2],[0,0,7,8,6,11,13,12,2],[0,0,7,9,6,11,13,12,2],[0,0,8,6,2],[0,0,7,9,6,10,11,13,12,2],[0,0,1,7,8,9,3],[19,0,1,2,3,1],[22,0,1,2,3,4,5,6,1],[25,0,1,2,3,4],[3,0,2,1],[12,0,1,2,3,4,3],[0,0,2,7,8,3],[0,0,1,7,9,10,3],[0,0,1,7,9,6,3],[3,0,2,1,1],[6,0,4,2],[0,0,7,8,6,10,11,13,12,2],[0,0,3,1,8,9,10,4],[0,0,3,1,7,8,9,10,4],[0,0,8,6,13,2],[28,0,1],[15,0,1,2,3,4,4],[52,0,1,1],[0,0,7,9,6,10,13,2],[0,0,8,6,10,11,12,2],[0,0,1,2,8,9,10,4],[0,0,2,7,3],[0,0,2,7,9,10,11,12,3],[0,0,2,7,9,3],[0,0,7,6,2],[0,0,7,9,6,10,2],[0,0,8,9,6,13,2],[0,0,8,6,10,11,13,12,2],[0,0,7,8,6,10,2],[0,0,3,7,8,9,6,3],[0,0,8,6,10,13,2],[0,0,7,8,9,6,2],[0,0,7,8,9,6,10,2],[4,0,1,2,6,3,4,5,3],[4,0,2,6,3,2],[17,0,1,2,3,2],[18,0,1,2,3,4,5,3],[5,0,3,2],[5,0,1,2,3,2],[11,0,1,2,3,4,5,2],[26,0,2],[3,0,1],[3,0,2,1,3,1],[27,0,1],[6,0,1,2,4,4],[6,0,3,4,3],[29,0,1,1],[30,0,1,1],[31,0,1,2,3,2],[32,0,1,2,3,4,1],[33,0,1,2,3,4,2],[34,0,1,2,3],[35,0,1,2,2],[36,0,1,2,3,4],[37,0,2],[38,0,1],[7,0,1,2,3,5,4,4],[7,0,1,3,5,3],[46,0,1,2,2],[47,0,1,2,3,4,5,4],[48,0,2],[16,0,1,4,2,3,7,6],[16,0,5,1,2,6,3,7,8,7],[49,0,1,2,1],[50,0,1,2,2],[51,0,1,1],[53,0,1,2,1],[54,0,1,2,3,4,3],[55,0,1,2,4]],[[[{"name":"water_icon","rect":{"x":5,"y":5,"width":119,"height":119},"offset":{"x":0.5,"y":-0.5},"originalSize":{"width":128,"height":128},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-59.5,-59.5,0,59.5,-59.5,0,-59.5,59.5,0,59.5,59.5,0],"indexes":[0,1,2,2,1,3],"uv":[5,123,124,123,5,4,124,4],"nuv":[0.0390625,0.03125,0.96875,0.03125,0.0390625,0.9609375,0.96875,0.9609375],"minPos":{"x":-59.5,"y":-59.5,"z":0},"maxPos":{"x":59.5,"y":59.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[16]],[[[17,"Zebra"],[29,"Zebra",[-3,-4],[[40,-2,[8,"dbdQOqy55dwoOwtMHe8ywW"],[4,5,6,7,8,9],10]],[0,"039JBGvFlf8Z44LUb1mPts",-1,0]],[33,"Body",[-5,-6,-7,-8,-9,-10,-11],[0,"bcLgyteNNV27PUD91CDWt7",1,0],[1,0.0000537765008630231,0.023020822554826736,-0.00017354160081595182]],[34,"root",[-12,2,-13,-14,-15],[0,"e0XluJCDhf+6IpwatEjaAr",1,0],[3,0.7071068407911908,0,0,0.7071067215818992],[1,90.00000965934633,0,0]],[35,"Armature",1,[3],[0,"a43NXxtVFSUp0gXk9cnTTh",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[5,"FrontFoot.R",3,[[4,"FrontFoot.R_end",-16,[0,"00q6WQILVfkI0nk97R1yJg",1,0],[1,-1.1102229998097382e-18,0.009999999776482582,1.3877787497621727e-19]]],[0,"26G2zfLaJV6p3pXLCbD9N1",1,0],[1,-0.009117710404098034,0.0010000348556786776,0.01927023008465767],[3,0.7071068407909181,-6.209646236899395e-7,-6.209645668465197e-7,0.7071067215816265],[1,90.00000965934633,3.87667620832701e-12,-0.0001006316202376715]],[3,"FrontLeg.R",2,[-17],[0,"7cvvge8h1eqYhfwRKBMoC8",1,0],[1,-0.0032468067947775126,0.008379977196455002,0.01873094029724598],[3,0.0012952884202324106,-0.0012955682826612425,0.7071055647628505,0.7071056243674941],[1,89.99867052826072,-89.99869320512238,89.79006673189204]],[3,"FrontUpLeg.R",6,[-18],[0,"fbw0dG7i5bDq3yrI7AmVDF",1,0],[1,2.4487718519594637e-9,0.006025583017617464,6.021457221727644e-10],[3,0.706853564541443,-0.7022758682440338,-0.04508993749057004,0.07164873142101912],[1,95.04363367817759,-75.48471135759631,-87.81611699616465]],[5,"FrontLowLeg.R",7,[[4,"FrontLowLeg.R_end",-19,[0,"17I0YOYJZe77jsuPq4wnew",1,0],[1,0,0.015877680853009224,2.2204459996194763e-18]]],[0,"ebM9V+OUNaqYSZ37r2WCA8",1,0],[1,8.19563861220729e-10,0.014804559759795666,7.450580430390374e-11],[3,0.1331460446931698,-0.018813656233402656,0.0025279523720033188,0.9909146212356041],[1,15.305631002608129,-2.175391787385122,0.000002412554620199633]],[3,"BackLeg.R",2,[-20],[0,"d31ezPuQBdoqALY0VA4m/o",1,0],[1,-0.0032468067947775126,0.008379977196455002,-0.021785270422697067],[3,0.0007835572993493648,-0.000784275465464433,0.7071063466516025,0.7071063466516025],[1,89.99997090402447,-90.00002909596121,89.87296088624299]],[3,"BackUpLeg.R",9,[-21],[0,"ee4UCnrSJe2b3ljjbrDZqe",1,0],[1,2.6392144025777498e-9,0.004695829935371876,2.844441349125759e-9],[3,-0.6711558061437017,0.6744514661419378,-0.20213857166258833,0.2319592669948692],[1,-65.8136082604064,78.42660923213249,-87.56878091632545]],[5,"BackLowLeg.R",10,[[4,"BackLowLeg.R_end",-22,[0,"1cPuoQCARYGKaLorOvmfjm",1,0],[1,0,0.021711884066462517,-4.440891999238953e-18]]],[0,"72stSJfeJXNJnpFcQSFCil",1,0],[1,-1.303851610012785e-10,0.010874390602111816,1.3783574281944766e-9],[3,-0.357463601726651,0.018072592270244717,0.0069187652060998615,0.9337265582263721],[1,-41.8972320491341,2.2176787497755472,-0.000006772635116469312]],[3,"FrontLeg.L",2,[-23],[0,"e50kmZqcRSjrv2uBCCZcVQ",1,0],[1,0.002630481729283929,0.008379977196455002,0.01873094029724598],[3,0.7071054153926467,0.7071054749972929,0.0013744056093762014,-0.0013746855882320113],[1,-89.99874639371293,-90.00123091999457,89.77724521028026]],[3,"FrontUpLeg.L",12,[-24],[0,"casBIDR31RNZxQF1bLWvwl",1,0],[1,-1.756112921746933e-9,0.006025584880262613,8.378248095297636e-10],[3,-0.02159131891643826,-0.0950879461007112,0.7079610872193227,0.6994878100703624],[1,91.83742545141908,-101.31553480725925,84.00249672666698]],[5,"FrontLowLeg.L",13,[[4,"FrontLowLeg.L_end",-25,[0,"7aeXYDUt1S+KXrJowprNxH",1,0],[1,0,0.015877680853009224,0]]],[0,"ddZDVMdZRXKpCgvszKorZ4",1,0],[1,5.21540644005114e-10,0.01480456069111824,-2.2351742678949904e-9],[3,0.13298889845622416,0.0518218384837552,-0.006963174712129553,0.9897373207783426],[1,15.30574958155501,5.994446392534305,0.0000017569448676354595]],[3,"BackLeg.L",2,[-26],[0,"77NLfLH8Rd3aKmeeYlgDTK",1,0],[1,0.002630481729283929,0.008379977196455002,-0.021785270422697067],[3,0.7071064108167839,0.7071065300260734,0.0006625798408461719,-0.000663298006965872],[1,0,180.10749206804024,90]],[3,"BackUpLeg.L",15,[-27],[0,"7e6BEk3+xcALhXps3XrGs0",1,0],[1,-1.7321695189309594e-9,0.004695831332355738,-5.743572839556066e-10],[3,0.20885529998403182,0.2254200118205795,0.6690967641935,0.6766644678754589],[1,-47.56156043426251,83.33119945023036,88.52430684541918]],[5,"BackLowLeg.L",16,[[4,"BackLowLeg.L_end",-28,[0,"03SpKvjMFb9olohS05c34L",1,0],[1,1.1102229998097382e-18,0.021711884066462517,0]]],[0,"90gs4K5rJe1r7sikxkoc+t",1,0],[1,1.3876706450588472e-9,0.010874389670789242,-2.9802322831784522e-9],[3,-0.3575146799690923,-0.008874606354457956,-0.003397634490841542,0.9338591708863375],[1,-41.897265414717886,-1.0889531390263516,-0.000012614001200186714]],[3,"Back",2,[-29],[0,"11H5cWjxhWw5fTzgwXOMxf",1,0],[1,-0.0003228271089028567,0.014074056409299374,-0.02402278035879135],[3,0.600521340713622,-0.03759600686347977,0.041032479214218334,0.797669728186403],[1,74.01189985905324,-6.273967195598808,1.1635466469197921]],[50,"Tail1",18,[-30],[0,"b1UV7XyElbs7MhIYNWkFVw",1,0],[1,0.00011168546916451305,0.0004445876111276448,-0.011115172877907753],[3,0.9926701262968977,2.6012603822892967e-8,2.4599262545988356e-7,-0.12085536958546711],[1,0.9999999403953552,1,1.0000046491622925],[1,-166.11705810797116,-0.000028342307693480152,-4.4777739656929585e-7]],[3,"Tail2",19,[-31],[0,"39GWKMQNJQJrBNwEAUfE8a",1,0],[1,2.2351741291171123e-10,0.008375221863389015,2.7951319037100575e-9],[3,-0.6165577197016351,9.049319550859618e-8,-7.07902219576156e-8,0.7873097092480869],[1,-76.13038874521422,0.000003162717130410351,-0.000012780179695139314]],[3,"Tail3",20,[-32],[0,"60zaADwUxW+riJAAxxPzQ5",1,0],[1,7.450580430390374e-11,0.008778817020356655,2.7101487720671003e-9],[3,-8.469585136089024e-9,0.9891947031850706,-0.14660777329493307,3.1860077274446467e-7],[1,16.860785764413208,179.99996402782003,-0.0000063125531820381505]],[5,"Tail4",21,[[4,"Tail4_end",-33,[0,"840iCwDEBf/7pY+rBYfctR",1,0],[1,2.7755574995243454e-19,0.01026824489235878,8.881783998477905e-18]]],[0,"c1ZDfAPalWS4xOAIvKOQq7",1,0],[1,3.7252903539730653e-10,0.006993296090513468,-1.0337680711458574e-9],[3,0.0390400249736085,3.436872089418752e-8,1.558242765283034e-8,0.9992376476344648],[1,4.474794507341863,0.000003865652445262186,0.0000019380072905949817]],[3,"Shoulders",2,[-34],[0,"e2ufLKktpWS4RregBsd5Nt",1,0],[1,-0.0007365465280599892,0.01807716116309166,0.01851993054151535],[3,0.008421451052746927,0.9597338069228858,0.2794420189265245,-0.02742730518551501],[1,-32.46892103661168,-176.71214203094826,0.04790039382298016]],[3,"Neck",23,[-35],[0,"8dc9HrWK5ccYXlIRQ5DFtN",1,0],[1,5.122274132629556e-11,0.013137188740074635,2.712476909749739e-10],[3,-0.0886846790567607,-0.022488868112285784,-0.017817650187023866,0.9956464281327185],[1,-10.223395129333626,-2.7493052912714067,-1.804618282098218]],[5,"Head",24,[[4,"Head_end",-36,[0,"32Fx0Bzz9Rj6qRK90xRrEa",1,0],[1,0,0.01775381900370121,1.776356799695581e-17]]],[0,"27g6JlW05VYJwy9fRAjp8z",1,0],[1,-2.39742808938459e-11,0.013573313131928444,3.3753928541102596e-9],[3,-0.6245374799606817,-0.19781437896428433,0.16660769604005599,0.7369289539837338],[1,-79.11122360848766,-5.502426603138088,29.51431895269537]],[3,"Hips",2,[-37],[0,"99pbKh6NpVja7rVyg0m0OU",1,0],[1,-0.0003228271089028567,0.016898196190595627,-0.014742005616426468],[3,0.000003487624764492713,0.6944211092559098,0.719568845209615,0.0000033658895813566903],[1,-92.03778993215424,-179.99998026259544,0.0005550665619484873]],[5,"Torso",26,[[4,"Torso_end",-38,[0,"b2Qye8OedX7YlFRWtTpkFW",1,0],[1,-6.938893748810864e-20,0.015270233154296875,0]]],[0,"d9UpW1h/xQRqg/GNOeN6xV",1,0],[1,2.1590436036222904e-11,0.014671733602881432,5.460347729524528e-10],[3,0.05375247793241081,0.0007617085899636836,-0.013526975106839246,0.9984623737831129],[1,6.165413201806021,0.1705337539528226,-1.5431884931505082]],[5,"BackFoot.R",3,[[4,"BackFoot.R_end",-39,[0,"46b6Gy3bFZIoQCziI47pmN",1,0],[1,0,0.006745369639247656,1.3877787497621727e-19]]],[0,"c8Mk7eSqhZMYRuukz9UwVY",1,0],[1,-0.008358624763786793,0.0010000348556786776,-0.026047201827168465],[3,0.7071068407909181,-6.209646236899395e-7,-6.209645668465197e-7,0.7071067215816265],[1,90.00000965934633,3.87667620832701e-12,-0.0001006316202376715]],[5,"FrontFoot.L",3,[[4,"FrontFoot.L_end",-40,[0,"eavUya1TxR3ICTc3/asXqx",1,0],[1,0,0.009999999776482582,1.3877787497621727e-19]]],[0,"07fN7vxPxXZYV+wAVDRws/",1,0],[1,0.008608940057456493,0.0010000348556786776,0.01927023008465767],[3,0.7071068407905415,-9.581394970415802e-7,-9.581393833547404e-7,0.70710672158125],[1,90.0000096593463,3.876676966638594e-12,-0.00015527314280957484]],[5,"BackFoot.L",3,[[4,"BackFoot.L_end",-41,[0,"33dt0ZamNRZJVf3cGHIpS/",1,0],[1,0,0.006745369639247656,2.7755574995243454e-19]]],[0,"d50PXwDJtRPKN7NDmUhqx+",1,0],[1,0.007849856279790401,0.0010000348556786776,-0.026047201827168465],[3,0.7071068407905415,-9.581394970415802e-7,-9.581393833547404e-7,0.70710672158125],[1,90.0000096593463,3.876676966638594e-12,-0.00015527314280957484]],[36,"Zebra",1,[[41,-42,[8,"98zNhp6XVRVqmvEikJRbcj"],[0,1],[14],1,2,3]],[0,"fae0lS5htShrNhw9tQV132",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]]],0,[0,2,1,0,0,1,0,-1,4,0,-2,31,0,-1,6,0,-2,9,0,-3,12,0,-4,15,0,-5,18,0,-6,23,0,-7,26,0,-1,5,0,-3,28,0,-4,29,0,-5,30,0,1,5,0,-1,7,0,-1,8,0,1,8,0,-1,10,0,-1,11,0,1,11,0,-1,13,0,-1,14,0,1,14,0,-1,16,0,-1,17,0,1,17,0,-1,19,0,-1,20,0,-1,21,0,-1,22,0,1,22,0,-1,24,0,-1,25,0,1,25,0,-1,27,0,1,27,0,1,28,0,1,29,0,1,30,0,0,31,0,5,1,2,1,3,3,1,4,42],[0,0,0,0,0,0,0,0,0,0,0],[-1,-2,6,11,-1,-2,-3,-4,-5,-6,12],[17,18,19,20,9,21,22,23,24,25,9]],[[[15,".bin",1440442756,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22752,"length":1896,"count":474,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22752,"count":474,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.6307587623596191,-0.008967475965619087,-0.7826605439186096],"maxPosition",8,[1,0.6515856385231018,0.6590640544891357,0.5341161489486694]]],-1],0,0,[],[],[]],[[[42,"Skin-0",1727875492,["Armature/root","Armature/root/FrontFoot.R","Armature/root/Body","Armature/root/Body/FrontLeg.R","Armature/root/Body/FrontLeg.R/FrontUpLeg.R","Armature/root/Body/FrontLeg.R/FrontUpLeg.R/FrontLowLeg.R","Armature/root/Body/BackLeg.R","Armature/root/Body/BackLeg.R/BackUpLeg.R","Armature/root/Body/BackLeg.R/BackUpLeg.R/BackLowLeg.R","Armature/root/Body/FrontLeg.L","Armature/root/Body/FrontLeg.L/FrontUpLeg.L","Armature/root/Body/FrontLeg.L/FrontUpLeg.L/FrontLowLeg.L","Armature/root/Body/BackLeg.L","Armature/root/Body/BackLeg.L/BackUpLeg.L","Armature/root/Body/BackLeg.L/BackUpLeg.L/BackLowLeg.L","Armature/root/Body/Back","Armature/root/Body/Back/Tail1","Armature/root/Body/Back/Tail1/Tail2","Armature/root/Body/Back/Tail1/Tail2/Tail3","Armature/root/Body/Back/Tail1/Tail2/Tail3/Tail4","Armature/root/Body/Shoulders","Armature/root/Body/Shoulders/Neck","Armature/root/Body/Shoulders/Neck/Head","Armature/root/Body/Hips","Armature/root/Body/Hips/Torso","Armature/root/BackFoot.R","Armature/root/FrontFoot.L","Armature/root/BackFoot.L"],[[[7,1,0,0,0,0,6.123234262925839e-17,-1,0,0,1,6.123234262925839e-17,0,0,0,0,1],[7,1,1.075455965353978e-22,-0.0000017563529581821058,0,-1.075455965353978e-22,-1,-1.2246468525851679e-16,0,-0.0000017563529581821058,1.2246468525851679e-16,-1,0,0.009117711335420609,-0.01927023008465767,0.0010000186739489436,1],[7,1,0,0,0,0,6.123234262925839e-17,-1,0,0,1,6.123234262925839e-17,0,-0.0000537765008630231,-0.023020826280117035,0.00017354160081595182,1],[7,-7.943073146920651e-14,-1,-3.956771479352028e-7,0,1.9470718370939721e-7,3.956771479352028e-7,-1,0,1,-1.5647192200783644e-13,1.9470718370939721e-7,0,-0.03140079602599144,-0.0031930229160934687,-0.018557406961917877,1],[7,0.9992793202400208,7.817317992930839e-8,0.03795882686972618,0,-0.03744172304868698,-0.16449666023254395,0.985666811466217,0,0.006244175601750612,-0.9863777756690979,-0.1643780767917633,0,0.008321077562868595,0.027920423075556755,0.023802941665053368,1],[7,0.9999998807907104,8.070195889331444e-8,1.987690723126434e-7,0,-2.0585146387475106e-7,0.10014060884714127,0.994973361492157,0,6.039142164127043e-8,-0.9949736595153809,0.10014057904481888,0,0.009218607097864151,0.01881570555269718,0.019205018877983093,1],[7,1.1920848663748984e-7,-1.0000001192092896,-0.0000010154482197322068,0,1.9470715528768778e-7,0.0000010154482197322068,-1,0,1.0000001192092896,1.1920828768552383e-7,1.947072689745255e-7,0,-0.031400807201862335,-0.0031930566765367985,0.02195880562067032,1],[7,0.9992508888244629,3.1871863370724896e-8,-0.03869609907269478,0,0.03139324113726616,0.584661602973938,0.8106695413589478,0,0.022624149918556213,-0.8112770915031433,0.584223747253418,0,0.006483175326138735,0.012636274099349976,-0.036451708525419235,1],[7,1,9.931482480851628e-8,1.284574153714857e-7,0,-1.1668206667536651e-7,-0.11062692850828171,0.9938617944717407,0,1.1291607648900026e-7,-0.9938619136810303,-0.11062690615653992,0,0.007888861000537872,0.025572653859853745,-0.02564503811299801,1],[7,-6.477578754415445e-14,1,-3.956770342483651e-7,0,-2.3215589806113712e-7,3.956770342483651e-7,1,0,1,1.566345387811821e-13,2.3215589806113712e-7,0,-0.03140080347657204,-0.002684251172468066,0.018557392060756683,1],[7,0.9945321083068848,4.430908617791829e-8,-0.10443182289600372,0,0.10300923138856888,-0.16449664533138275,0.9809842109680176,0,-0.017178641632199287,-0.9863777160644531,-0.16359718143939972,0,-0.006211212836205959,0.027920419350266457,0.0242511797696352,1],[7,1,7.040221561283033e-8,2.3092101741895021e-7,0,-2.368103366734431e-7,0.10014048963785172,0.994973361492157,0,4.6923773311391415e-8,-0.9949734210968018,0.10014048218727112,0,-0.00870984885841608,0.01881568878889084,0.019205018877983093,1],[7,-9.405196890396872e-13,1,-0.0000010154477649848559,0,-8.922222605178831e-8,0.0000010154477649848559,1,0,1,1.0311201762217004e-12,8.922222605178831e-8,0,-0.03140079602599144,-0.0026842805091291666,-0.021958813071250916,1],[7,0.9998193979263306,-2.6094554073097243e-8,0.01900486648082733,0,-0.01541819702833891,0.5846618413925171,0.8111305236816406,0,-0.011111441068351269,-0.8112771511077881,0.5845562219619751,0,-0.006691282149404287,0.012636265717446804,-0.036307260394096375,1],[7,1,3.1782598775009774e-9,2.6798463181876286e-7,0,-2.6598817726153356e-7,-0.11062703281641006,0.9938620328903198,0,3.280509730529957e-8,-0.9938620924949646,-0.11062702536582947,0,-0.0073800827376544476,0.025572657585144043,-0.025645041838288307,1],[7,1,1.3010425425610684e-22,4.76837158203125e-7,0,1.3881683003091894e-7,-0.9566864967346191,-0.2911199927330017,0,4.56183670394239e-7,0.2911199927330017,-0.9566864967346191,0,0.00026903030811809003,0.012349234893918037,0.04253220558166504,1],[7,1,1.2409302752036666e-10,4.582857964646747e-12,0,-1.2416137562532015e-10,0.9985907673835754,0.053069405257701874,0,2.009153694110255e-12,-0.05306966230273247,0.9985859990119934,0,0.00015737058129161596,-0.024428974837064743,-0.04922361299395561,1],[7,1,-2.3420737571555605e-10,2.3842022756070946e-7,0,-2.3413187477672182e-7,0.18785133957862854,0.9821969270706177,0,-4.501780992427484e-8,-0.9821930527687073,0.18785202503204346,0,0.00015738098591100425,0.039924945682287216,-0.04364730417728424,1],[7,-1,7.035073912309286e-11,3.8943693425608217e-7,0,-3.8728725826331356e-7,-0.10510523617267609,-0.9944610595703125,0,4.0862090600057854e-8,-0.9944562911987305,0.10510572791099548,0,-0.00015735780471004546,0.042466901242733,0.03273717686533928,1],[7,-1,5.799694946517775e-8,3.1960988167156756e-7,0,-3.2482691381119366e-7,-0.18237243592739105,-0.9832294583320618,0,1.263730675660213e-9,-0.983224630355835,0.18237334489822388,0,-0.00015735880879219621,0.03791962191462517,0.029869725927710533,1],[7,-0.9983536601066589,0.03149224445223808,-0.04793712869286537,0,-0.05735006928443909,-0.5359179973602295,0.8423197865486145,0,0.0008361703949049115,0.8436827659606934,0.536841630935669,0,-0.0017681776080280542,-0.044484321027994156,-0.00664231413975358,1],[7,-1.0000001192092896,1.0994877008840831e-8,0.000005181227152206702,0,0.000003803521849476965,-0.6774875521659851,0.7355341911315918,0,0.0000035183045383746503,0.7355343699455261,0.6774874925613403,0,-0.0002691377012524754,-0.055580634623765945,-0.016679488122463226,1],[7,-0.8662223815917969,-0.0015339370584115386,0.4996565282344818,0,-0.27237826585769653,-0.8368988037109375,-0.4747740626335144,0,0.41889023780822754,-0.5473552942276001,0.7245228886604309,0,-0.035693008452653885,0.005083934403955936,-0.06132461130619049,1],[7,-1,2.092813905030591e-13,0.000009687739293440245,0,-3.4448314067958563e-7,-0.9993674159049988,-0.03555864840745926,0,0.000009681612027634401,-0.03555864840745926,0.9993675351142883,0,-0.00026943194097839296,0.016325578093528748,-0.03936338797211647,1],[7,-0.9996330142021179,-0.02709319442510605,-0.00005722550122300163,0,0.02701888047158718,-0.9970430135726929,0.07193925976753235,0,-0.0020061202812939882,0.0719112902879715,0.9974091053009033,0,-0.00019675440853461623,-0.0025880569592118263,-0.039313461631536484,1],[7,1,1.075455965353978e-22,-0.0000017563529581821058,0,-1.075455965353978e-22,-1,-1.2246468525851679e-16,0,-0.0000017563529581821058,1.2246468525851679e-16,-1,0,0.008358626626431942,0.026047201827168465,0.0010000200709328055,1],[7,1,1.6594129641253459e-22,-0.0000027100270472146804,0,-1.6594129641253459e-22,-1,-1.2246468525851679e-16,0,-0.0000027100270472146804,1.2246468525851679e-16,-1,0,-0.00860893726348877,-0.01927023008465767,0.001000058138743043,1],[7,1,1.6594129641253459e-22,-0.0000027100270472146804,0,-1.6594129641253459e-22,-1,-1.2246468525851679e-16,0,-0.0000027100270472146804,1.2246468525851679e-16,-1,0,-0.007849853485822678,0.026047201827168465,0.00100005604326725,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[15,".bin",3057132391,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":76416,"length":6984,"count":1746,"stride":4}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[1],"indexView":{"offset":184648,"length":9264,"count":2316,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":76416,"count":1194,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":83400,"length":101248,"count":1582,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24,25,26,27]]},"minPosition",8,[1,-0.012848868034780025,-0.050709761679172516,-0.00044154166243970394],"maxPosition",8,[1,0.012848868034780025,0.04164161533117294,0.07027643173933029]]],-1],0,0,[],[],[]],[[[27,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":9.607843137254903,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4281348144],"emissive",8,[4,4281348144]],{},{}],11,0,0]]],0,0,[0],[8],[2]],[[[27,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":9.607843137254903,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]],{},{}],11,0,0]]],0,0,[0],[8],[2]],[[{"name":"btn_cancel","rect":{"x":0,"y":0,"width":54,"height":54},"offset":{"x":0,"y":0},"originalSize":{"width":54,"height":54},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-27,-27,0,27,-27,0,-27,27,0,27,27,0],"indexes":[0,1,2,2,1,3],"uv":[0,54,54,54,0,0,54,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-27,"y":-27,"z":0},"maxPos":{"x":27,"y":27,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[26]],[[[24,"block_mtl",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"occlusion":1,"roughness":1,"metallic":0},"mainColor",8,[4,4278215364]],{},{}],11,0,0]]],0,0,[0],[8],[7]],[[[15,".bin",3219909449,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[[27,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"DCC_APP_NAME":1,"USE_ALBEDO_MAP":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":1.0717734098434448,"specularFactor":0},"mainColor",8,[4,4293914607],"specularColor",8,[4,4278190080],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[14,8],[10,2]],[[[15,".bin",3103554793,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":212632,"length":17364,"count":4341,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":212632,"count":3797,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-6.501608371734619,-0.007862635888159275,-14.762481689453125],"maxPosition",8,[1,20.59972381591797,18.1842098236084,2.870004177093506]]],-1],0,0,[],[],[]],[[[15,".bin",321897862,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2304,"length":252,"count":126,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":2304,"count":48,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.18022269010543823,-0.01484794169664383,-0.15672263503074646],"maxPosition",8,[1,0.18022271990776062,0.01719527691602707,0.15672263503074646]]],-1],0,0,[],[],[]],[[[27,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.5778115391731262,0.23347531259059906,0.11534765362739563]],{},{}],11,0,0]]],0,0,[0],[8],[7]],[[[32],[37,"farm_plot_slot",[-2],[0,"047WPd4YhflLipehZ6gK4y",-1,0]],[57,"farm_plot_slot",1,[[21,-3,[8,"b8jH+yTS1ZlK/kjb3wvwLp"],[0],[14],1]],[0,"4bxf/9yPpVMZGAn0aI9L/H",1,0],[1,-0.4311656355857849,0.03844444081187248,-0.37951305508613586],[1,1,1,1.0905308723449707]]],0,[0,2,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,6],[11,27]],[[{"name":"default_progressbar","rect":{"x":0,"y":0,"width":30,"height":15},"offset":{"x":0,"y":0},"originalSize":{"width":30,"height":15},"rotated":false,"capInsets":[10,4,10,4],"vertices":{"rawPosition":[-15,-7.5,0,15,-7.5,0,-15,7.5,0,15,7.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,15,30,15,0,0,30,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-15,"y":-7.5,"z":0},"maxPos":{"x":15,"y":7.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[28]],[[[15,".bin",2723892759,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":44744,"length":5076,"count":1269,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":44744,"count":799,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-6.926687240600586,-8.290106773376465,-8.290106773376465],"maxPosition",8,[1,9.071044921875,8.290106773376465,8.290106773376465]]],-1],0,0,[],[],[]],[[[15,".bin",1955488527,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":224336,"length":18228,"count":4557,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":224336,"count":4006,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-12.112174987792969,-0.007862542755901814,-7.520937919616699],"maxPosition",8,[1,9.892732620239258,18.10137939453125,18.683460235595703]]],-1],0,0,[],[],[]],[[[32],[37,"WaterWheel",[-2],[0,"27mzaN23VR478JJDBj4b/o",-1,0]],[3,"WaterWheel",1,[-3,-4],[0,"c9E10DwfZfGr9iiyNV2Q3b",1,0],[1,-11.939798355102539,0.043095625936985016,-35.962677001953125],[3,0.7071068109888685,0,0,0.7071067513842252],[1,90.00000482967297,0,0]],[38,"House",2,[[21,-5,[8,"c2dMW41uRXa4Je62YT7TtT"],[0],[14],1]],[0,"2dFZSF3XFTtaZs0eguzDvn",1,0],[1,-2.280874729156494,-0.4368973672389984,-0.0030959350988268852],[3,-0.5000000074505778,0.5000000670552235,-0.5000000074505778,0.4999999180436093],[1,0.3937009871006012,0.3937009871006012,0.3937009871006012],[1,0,90.00001024528467,-90]],[38,"Wheel",2,[[21,-6,[8,"78y6shdSFbrqfdRih7IyLX"],[2],[14],3]],[0,"f52A77uAhafL+n37f8pJ9h",1,0],[1,2.5148324966430664,-0.4368911683559418,-2.689953565597534],[3,-2.2197246021453134e-7,0.7071068407911687,-0.707106721581877,-1.1520233497803665e-7],[1,0.3937009871006012,0.3937009871006012,0.3937009871006012],[1,89.99999034065574,-179.99997267924348,-0.000008651422027537246]]],0,[0,2,1,0,-1,2,0,-1,3,0,-2,4,0,0,3,0,0,4,0,5,1,6],[0,0,0,0],[-1,6,-1,6],[12,29,12,30]],[[[24,"Village_Autumn",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true,"DCC_APP_NAME":1}],[[[{"albedoScale":1,"specularFactor":0,"shininessExponent":1.0717734098434448,"emissiveScale":0},"mainColor",8,[4,4293914607],"specularColor",8,[4,4278190080],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[14,8],[31,2]],[[[17,"HouseA"],[58,"HouseA",[-2],[0,"206WFyActfFYab8VYGP3ll",-1,0],[1,49.28,0.608,-18.741],[3,0,-0.9999961977677757,0,0.002757616723112648],[1,0,-179.684,0]],[30,"House01",1,[[21,-3,[8,"049j7gnZVdm5F/bgr6/701"],[0],[14],1]],[0,"53DFtdNilehYcEyqcOV2cC",1,0]]],0,[0,2,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,6],[32,33]],[[[42,"Skin-0",838716580,["Armature/root","Armature/root/FrontFoot.R","Armature/root/Body","Armature/root/Body/FrontLeg.R","Armature/root/Body/FrontLeg.R/FrontUpLeg.R","Armature/root/Body/FrontLeg.R/FrontUpLeg.R/FrontLowLeg.R","Armature/root/Body/BackLeg.R","Armature/root/Body/BackLeg.R/BackUpLeg.R","Armature/root/Body/BackLeg.R/BackUpLeg.R/BackLowLeg.R","Armature/root/Body/FrontLeg.L","Armature/root/Body/FrontLeg.L/FrontUpLeg.L","Armature/root/Body/FrontLeg.L/FrontUpLeg.L/FrontLowLeg.L","Armature/root/Body/BackLeg.L","Armature/root/Body/BackLeg.L/BackUpLeg.L","Armature/root/Body/BackLeg.L/BackUpLeg.L/BackLowLeg.L","Armature/root/Body/Back","Armature/root/Body/Shoulders","Armature/root/Body/Shoulders/Neck","Armature/root/Body/Shoulders/Neck/Head","Armature/root/Body/Hips","Armature/root/Body/Hips/Torso","Armature/root/BackFoot.R","Armature/root/FrontFoot.L","Armature/root/BackFoot.L"],[[[7,0.6545860767364502,1.4534733326815091e-16,-1.4534733326815091e-16,0,1.4534733326815091e-16,-0.6545860767364502,2.8612868518962387e-8,0,-1.4534733326815091e-16,-2.8612868518962387e-8,-0.6545860767364502,0,0,0,0,1],[7,0.6545860767364502,-1.453472538588121e-16,-0.0000013057496062174323,0,0.0000013057496062174323,2.8612868518962387e-8,0.6545860767364502,0,5.693078522711961e-14,-0.6545860767364502,2.8612868518962387e-8,0,0.009117711335420609,-0.011625418439507484,0.0010000165784731507,1],[7,0.6545860767364502,1.4534733326815091e-16,-1.4534733326815091e-16,0,1.4534733326815091e-16,-0.6545860767364502,2.8612868518962387e-8,0,-1.4534733326815091e-16,-2.8612868518962387e-8,-0.6545860767364502,0,-0.0000537765008630231,-0.023020826280117035,0.00017354160081595182,1],[7,-5.184890263985019e-14,-0.6545860767364502,-2.590047643025173e-7,0,-0.6545860767364502,9.09575352862034e-14,-9.883975593538707e-8,0,9.883975593538707e-8,2.590047643025173e-7,-0.6545860767364502,0,-0.023755986243486404,-0.003193025942891836,-0.010912593454122543,1],[7,0.6541142463684082,-3.841500628709582e-8,0.024847334250807762,0,-0.0049081165343523026,0.6416882276535034,0.12920880317687988,0,-0.024357758462429047,-0.12930196523666382,0.6412259340286255,0,0.008627776987850666,0.02113231085240841,0.015728982165455818,1],[7,0.6545859575271606,-6.379059414030053e-8,1.869221364358964e-7,0,9.064345363185566e-8,0.6474373936653137,-0.09647613763809204,0,-1.7547901620673656e-7,0.09647613763809204,0.6474373936653137,0,0.009218609891831875,0.01351012010127306,0.011482090689241886,1],[7,7.803221535596094e-8,-0.654586136341095,-6.646983479186019e-7,0,-0.654586136341095,-7.803210877455058e-8,-9.883981277880594e-8,0,9.883974172453236e-8,6.646984047620208e-7,-0.6545860767364502,0,-0.023755991831421852,-0.0031930459663271904,0.012262948788702488,1],[7,0.6540958285331726,-3.386928071336115e-8,-0.025329867377877235,0,-0.014809380285441875,0.5310505628585815,-0.38242489099502563,0,0.020549559965729713,0.3827114403247833,0.5306529402732849,0,0.0069605209864676,0.012103005312383175,-0.024125296622514725,1],[7,0.6545860767364502,8.0905614652238e-8,3.775164714170387e-8,0,-8.614277646756818e-8,0.6450719833374023,0.11119811981916428,0,-2.3459071130105258e-8,-0.11119812726974487,0.6450719237327576,0,0.007888859137892723,0.017880013212561607,-0.01581326127052307,1],[7,-4.225598007352033e-14,0.6545860767364502,-2.5900470745909843e-7,0,-0.6545860767364502,-1.1370690901433417e-13,-1.8057889406009053e-7,0,-1.8057889406009053e-7,2.5900470745909843e-7,0.6545860767364502,0,-0.023755989968776703,-0.0026842537336051464,0.010912584140896797,1],[7,0.651006817817688,-4.206251347227408e-8,-0.0683596208691597,0,0.01350327953696251,0.641688346862793,0.12859492003917694,0,0.06701269000768661,-0.12930195033550262,0.6381796598434448,0,-0.007054996211081743,0.021132322028279305,0.016215577721595764,1],[7,0.6545860171318054,-4.6941035947156706e-8,1.6639584998756618e-7,0,7.095266596479632e-8,0.6474375128746033,-0.09647621959447861,0,-1.5766026706387493e-7,0.0964762344956398,0.647437334060669,0,-0.008709844201803207,0.013510128483176231,0.011482084169983864,1],[7,-6.155057474983849e-13,0.6545860767364502,-6.646980068580888e-7,0,-0.6545860767364502,-7.038664898324776e-13,-8.701650244802295e-8,0,-8.701650244802295e-8,6.646980068580888e-7,0.6545860767364502,0,-0.023755986243486404,-0.002684270730242133,-0.012262954376637936,1],[7,0.6544678807258606,-1.9434759579439742e-8,0.012440373189747334,0,0.007273427676409483,0.5310506820678711,-0.3826424479484558,0,-0.010092577897012234,0.3827115297317505,0.5309548377990723,0,-0.006925718393176794,0.012103002518415451,-0.02397383376955986,1],[7,0.6545860767364502,-4.0484302132881567e-8,1.8150498704017082e-7,0,9.062634198642172e-9,0.6450719237327576,0.11119817197322845,0,-1.8574417026684387e-7,-0.11119814962148666,0.6450721025466919,0,-0.007380083668977022,0.01788000762462616,-0.015813268721103668,1],[7,0.6545860767364502,7.040943586359479e-15,3.121311067388888e-7,0,-2.986116385272908e-7,-0.19056308269500732,0.626233696937561,0,9.08676085487059e-8,-0.626233696937561,-0.19056308269500732,0,0.0002690349647309631,0.011455359868705273,0.032788027077913284,1],[7,-0.6537306904792786,0.0209315437823534,-0.02609533630311489,0,0.005159350577741861,-0.4414235055446625,-0.4833236634731293,0,-0.03305263817310333,-0.48289796710014343,0.4406815469264984,0,-0.0009414005326107144,-0.025078032165765762,-0.01247877161949873,1],[7,-0.6545860171318054,9.814099755089956e-9,0.000003365599468452274,0,-0.0000021032255972386338,-0.5122209787368774,-0.40756934881210327,0,0.0000026275079108017962,-0.40756955742836,0.5122207403182983,0,-0.00031612793100066483,-0.0366215817630291,-0.006748612970113754,1],[7,-0.5670154690742493,-0.001055598957464099,0.327070951461792,0,-0.27481433749198914,0.3564779758453369,-0.4752722680568695,0,-0.17735153436660767,-0.5490040183067322,-0.3092314898967743,0,-0.023631738498806953,0.0022684389259666204,-0.04032844677567482,1],[7,-0.6545860767364502,1.3684226549213335e-13,0.000006341459538816707,0,-0.000006337448667181889,0.023276226595044136,-0.6541720628738403,0,-2.2549417622030887e-7,-0.6541720032691956,-0.023276228457689285,0,-0.00026934550260193646,0.012313800863921642,-0.03043850138783455,1],[7,-0.654168963432312,-0.023360740393400192,0.00043338880641385913,0,0.0017825023969635367,-0.062004510313272476,-0.6516404151916504,0,0.023296669125556946,-0.6512239575386047,0.06202862039208412,0,-0.00006388637848431244,-0.006304203998297453,-0.02987286075949669,1],[7,0.6545860767364502,-1.453472538588121e-16,-0.0000013057496062174323,0,0.0000013057496062174323,2.8612868518962387e-8,0.6545860767364502,0,5.693078522711961e-14,-0.6545860767364502,2.8612868518962387e-8,0,0.008358626626431942,0.01635134220123291,0.0010000180918723345,1],[7,0.6545860767364502,-1.453472141541427e-16,-0.000001930011421791278,0,0.000001930011421791278,2.8612868518962387e-8,0.6545860767364502,0,8.421814135829708e-14,-0.6545860767364502,2.8612868518962387e-8,0,-0.00860893726348877,-0.011625418439507484,0.001000060117803514,1],[7,0.6545860767364502,-1.453472141541427e-16,-0.000001930011421791278,0,0.000001930011421791278,2.8612868518962387e-8,0.6545860767364502,0,8.421814135829708e-14,-0.6545860767364502,2.8612868518962387e-8,0,-0.007849853485822678,0.01635134220123291,0.0010000579059123993,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[15,".bin",2757250274,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":40576,"length":3720,"count":930,"stride":4}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[1],"indexView":{"offset":84488,"length":3600,"count":900,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":40576,"count":634,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":44296,"length":40192,"count":628,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]]},"minPosition",8,[1,-0.0169683750718832,-0.06644736975431442,-0.05363176763057709],"maxPosition",8,[1,0.0169683750718832,0.00015554428682662547,0.036795418709516525]]],-1],0,0,[],[],[]],[[[24,"Black",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":9.607843137254903,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4281742902],"emissive",8,[4,4281742902]]],11]]],0,0,[0],[8],[2]],[[[24,"White",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":9.607843137254903,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4293388263]]],11]]],0,0,[0],[8],[2]],[[{"name":"bug_icon","rect":{"x":5,"y":5,"width":119,"height":119},"offset":{"x":0.5,"y":-0.5},"originalSize":{"width":128,"height":128},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-59.5,-59.5,0,59.5,-59.5,0,-59.5,59.5,0,59.5,59.5,0],"indexes":[0,1,2,2,1,3],"uv":[5,123,124,123,5,4,124,4],"nuv":[0.0390625,0.03125,0.96875,0.03125,0.0390625,0.9609375,0.96875,0.9609375],"minPos":{"x":-59.5,"y":-59.5,"z":0},"maxPos":{"x":59.5,"y":59.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[34]],[[[15,".bin",3195812956,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":101424,"length":8928,"count":2232,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":101424,"count":2113,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.7570797801017761,-0.04452315345406532,-0.9673821330070496],"maxPosition",8,[1,0.5575165152549744,2.4303321838378906,0.5997433066368103]]],-1],0,0,[],[],[]],[[[79,"Garden"],[51,"PopupSelectSeed",false,33554432,[-4,-5,-6,-7,-8,-9,-10],[[9,-1,[5,100,120]],[82,-2],[49,20,-3]],[1,0,-260,0]],[51,"PopupTool",false,33554432,[-14,-15,-16,-17,-18,-19],[[9,-11,[5,100,120]],[54,-12],[49,20,-13]],[1,0,-260,0]],[59,"UI_Canvas",33554432,"81+w69Bx5IVLhSvPTQ9RM7",[-26,1,2,-27,-28],[[9,-20,[5,960,640]],[85,-22,-21],[83,45,-5.684341886080802e-14,-5.684341886080802e-14,-23],[86,-25,-24]],[1,479.99999999999994,320,0]],[87,"Garden",[[-43,-44,-45,[60,"PlantGroup","31Fo8XuCtBSJqATup1PpHY",-46],3,-47,-48,-49,-50],1,1,1,4,1,1,1,1,1],[76,"3e72df98-dfd0-40a5-9025-29c11e6f1677",[-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42]],[88,[89,0.5208,[2,0.21465,0.34977,0.576641,0.520833125],[2,0.245603,0.246646,0.251197,0],[2,0.36244,0.486029,0.632565,0.5208],[2,0.437391,0.436011,0.436589,0]],[90,1,30,[4,4278190080]],[91,292,54,55],[92,true,400,1000,[4,4294759134]],[93,true]]],[52,"PopupBuyZoo",false,33554432,3,[-55,-56,-57],[[9,-51,[5,100,120]],[54,-52],[49,20,-53],[94,-54]],[1,0,-260,0]],[45,"LandGroup","db3lCbtrtPsaLlLDrYtRaH",4,[-58,-59,-60,-61,-62,-63]],[23,"ButtonSeed_1",33554432,1,[-67],[[9,-64,[5,80,80]],[12,1,0,-65,14],[19,3,1.1,-66,[[31,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_00",1]]]],[1,-200,0,0]],[23,"ButtonSeed_2",33554432,1,[-71],[[9,-68,[5,80,80]],[12,1,0,-69,15],[19,3,1.1,-70,[[31,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_01",1]]]],[1,-100,0,0]],[39,"ButtonSeed_3",33554432,1,[-75],[[9,-72,[5,80,80]],[12,1,0,-73,16],[19,3,1.1,-74,[[31,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_02",1]]]]],[23,"ButtonSeed_4",33554432,1,[-79],[[9,-76,[5,80,80]],[12,1,0,-77,17],[19,3,1.1,-78,[[31,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_03",1]]]],[1,100,0,0]],[23,"ButtonSeed_5",33554432,1,[-83],[[9,-80,[5,80,80]],[12,1,0,-81,18],[19,3,1.1,-82,[[31,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_04",1]]]],[1,200,0,0]],[23,"ButtonWatter",33554432,2,[-87],[[9,-84,[5,80,80]],[12,1,0,-85,21],[19,3,1.1,-86,[[22,"9ddefGqg0dAVpQkQmCMz4vd","water",2]]]],[1,-100,0,0]],[39,"ButtonFertilize",33554432,2,[-91],[[9,-88,[5,80,80]],[12,1,0,-89,22],[19,3,1.1,-90,[[22,"9ddefGqg0dAVpQkQmCMz4vd","fertilize",2]]]]],[52,"ButtonMove",false,33554432,2,[-95],[[9,-92,[5,80,80]],[12,1,0,-93,23],[19,3,1.1,-94,[[22,"9ddefGqg0dAVpQkQmCMz4vd","move",2]]]],[1,100,0,0]],[23,"ButtonHarvest",33554432,2,[-99],[[9,-96,[5,80,80]],[12,1,0,-97,24],[19,3,1.1,-98,[[22,"9ddefGqg0dAVpQkQmCMz4vd","harvest",2]]]],[1,100,0,0]],[39,"ButtonBuy",33554432,5,[-103],[[9,-100,[5,80,80]],[12,1,0,-101,28],[44,3,1.1,-102,[[22,"b9c5214VhNJQ5Ow6JKl8ENE","buyZoo",5]],29]]],[39,"Footer",33554432,3,[-106,-107],[[80,-104],[84,20,270,-105]]],[23,"ButtonFarm",33554432,17,[-111],[[9,-108,[5,80,80]],[12,1,0,-109,30],[44,3,1.1,-110,[[22,"f1b36959pFKfZ6QG9FL2X6r","onBtnFarmClick",3]],31]],[1,410.00000000000006,-260,0]],[23,"ButtonZoo",33554432,17,[-115],[[9,-112,[5,80,80]],[12,1,0,-113,32],[44,3,1.1,-114,[[22,"f1b36959pFKfZ6QG9FL2X6r","onBtnZooClick",3]],33]],[1,410.00000000000006,-156.773,0]],[1,["27mzaN23VR478JJDBj4b/o"]],[45,"ZooGroup","7bl4qWsrZNUKt3X1/6b6y7",4,[-116,-117,-118,-119]],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[46,"ButtonClose",33554432,1,[[9,-120,[5,40,40]],[12,1,0,-121,13],[19,3,1.1,-122,[[22,"88b43Dzh+dBnLrzmp5945Wu","hide",1]]]],[1,271.28,59.907,0]],[46,"ButtonClose",33554432,2,[[9,-123,[5,40,40]],[12,1,0,-124,20],[19,3,1.1,-125,[[22,"9ddefGqg0dAVpQkQmCMz4vd","hide",2]]]],[1,170.358,55,0]],[46,"ButtonClose",33554432,5,[[9,-126,[5,40,40]],[12,1,0,-127,26],[44,3,1.1,-128,[[22,"9ddefGqg0dAVpQkQmCMz4vd","hide",5]],27]],[1,93.652,55,0]],[45,"Map","4234jM/9ZEpLD8qxEoXvg3",4,[-129,-130,-131]],[1,["fcTF/wge1Yj4RHb3yuihdn"]],[1,["0eMbovdd9awYI3A+Yj2ebm"]],[10,0,{},6,[11,"c46/YsCPVOJYA4mWEpNYRx",-132,[25,"91myVePqtG0KG+96UPpwZe",[[26,"Land_0",["_name"],22],[7,["_lpos"],22,[1,9.603,0,5.983]],[7,["_lrot"],22,[3,0,0,0,1]],[7,["_euler"],22,[1,0,0,0]],[6,false,["_active"],[1,["77sS0FYT9Oi5maUtqiA0oi"]]],[16,["_materials","0"],[1,["4fV5cw7A9JPr8g1JqKJnM0","a1RWhhznVfRrhgZTGNnBmD"]],1]]],0]],[10,0,{},6,[11,"c46/YsCPVOJYA4mWEpNYRx",-133,[25,"bfwJG1cB1JsqDtIpsuTqJP",[[26,"Land_1",["_name"],23],[7,["_lpos"],23,[1,27.938,0,5.983]],[7,["_lrot"],23,[3,0,0,0,1]],[7,["_euler"],23,[1,0,0,0]],[6,false,["_active"],[1,["77sS0FYT9Oi5maUtqiA0oi"]]],[16,["_materials","0"],[1,["4fV5cw7A9JPr8g1JqKJnM0","a1RWhhznVfRrhgZTGNnBmD"]],3]]],2]],[10,0,{},6,[11,"c46/YsCPVOJYA4mWEpNYRx",-134,[25,"0cOQGT99RLW5hcRcUKrRdX",[[26,"Land_2",["_name"],24],[7,["_lpos"],24,[1,46.076,0,5.983]],[7,["_lrot"],24,[3,0,0,0,1]],[7,["_euler"],24,[1,0,0,0]],[6,false,["_active"],[1,["77sS0FYT9Oi5maUtqiA0oi"]]],[16,["_materials","0"],[1,["4fV5cw7A9JPr8g1JqKJnM0","a1RWhhznVfRrhgZTGNnBmD"]],5]]],4]],[10,0,{},6,[11,"c46/YsCPVOJYA4mWEpNYRx",-135,[28,"67wpiUee9Mebraow+H4y3P",null,[[6,"Land_3",["_name"],[1,["c46/YsCPVOJYA4mWEpNYRx"]]],[2,["_lpos"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,9.603,0,26.677]],[2,["_lrot"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[3,0,0,0,1]],[2,["_euler"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,0,0,0]],[6,false,["_active"],[1,["77sS0FYT9Oi5maUtqiA0oi"]]],[16,["_materials","0"],[1,["4fV5cw7A9JPr8g1JqKJnM0","a1RWhhznVfRrhgZTGNnBmD"]],7]]],6]],[10,0,{},6,[11,"c46/YsCPVOJYA4mWEpNYRx",-136,[25,"cfjR9VaAVPqLMKA5JxjSfb",[[26,"Land_4",["_name"],25],[7,["_lpos"],25,[1,27.989,0,26.761]],[7,["_lrot"],25,[3,0,0,0,1]],[7,["_euler"],25,[1,0,0,0]],[6,false,["_active"],[1,["77sS0FYT9Oi5maUtqiA0oi"]]],[16,["_materials","0"],[1,["4fV5cw7A9JPr8g1JqKJnM0","a1RWhhznVfRrhgZTGNnBmD"]],9]]],8]],[10,0,{},6,[11,"c46/YsCPVOJYA4mWEpNYRx",-137,[25,"d9qshyl1xEGLdPGS8K+Sls",[[26,"Land_5",["_name"],26],[7,["_lpos"],26,[1,46.274,0,26.814]],[7,["_lrot"],26,[3,0,0,0,1]],[7,["_euler"],26,[1,0,0,0]],[6,false,["_active"],[1,["77sS0FYT9Oi5maUtqiA0oi"]]],[16,["_materials","0"],[1,["4fV5cw7A9JPr8g1JqKJnM0","a1RWhhznVfRrhgZTGNnBmD"]],11]]],10]],[13,"Background",33554432,1,[[9,-138,[5,550,120]],[12,1,0,-139,12]]],[13,"Label",33554432,7,[[9,-140,[5,68.96,50.4]],[18,"Seed_1",20,20,-141]]],[13,"Label",33554432,8,[[9,-142,[5,68.96,50.4]],[18,"Seed_2",20,20,-143]]],[13,"Label",33554432,9,[[9,-144,[5,68.96,50.4]],[18,"Seed_3",20,20,-145]]],[13,"Label",33554432,10,[[9,-146,[5,68.96,50.4]],[18,"Seed_4",20,20,-147]]],[13,"Label",33554432,11,[[9,-148,[5,68.96,50.4]],[18,"Seed_5",20,20,-149]]],[13,"Background",33554432,2,[[9,-150,[5,350,120]],[12,1,0,-151,19]]],[13,"Label",33554432,12,[[9,-152,[5,52.6,50.4]],[18,"Water",20,20,-153]]],[13,"Label",33554432,13,[[9,-154,[5,70.01,50.4]],[18,"Fertilize",20,20,-155]]],[13,"Label",33554432,14,[[9,-156,[5,48.91,50.4]],[18,"Move",20,20,-157]]],[13,"Label",33554432,15,[[9,-158,[5,68.91,50.4]],[18,"Harvest",20,20,-159]]],[13,"Background",33554432,5,[[9,-160,[5,200,120]],[12,1,0,-161,25]]],[13,"Label",33554432,16,[[9,-162,[5,34.46,50.4]],[18,"Buy",20,20,-163]]],[13,"Label",33554432,18,[[9,-164,[5,46.66,50.4]],[18,"Farm",20,20,-165]]],[13,"Label",33554432,19,[[9,-166,[5,34.46,50.4]],[18,"Zoo",20,20,-167]]],[10,0,{},30,[11,"52FZ4kbjJQ05Bh9aFNRMya",-168,[28,"fdf3GOOURJuoxPWqL0VgcB",null,[[6,"Map_BG",["_name"],[1,["52FZ4kbjJQ05Bh9aFNRMya"]]],[2,["_lpos"],[1,["52FZ4kbjJQ05Bh9aFNRMya"]],[1,28.096,0,142.128]],[2,["_lrot"],[1,["52FZ4kbjJQ05Bh9aFNRMya"]],[3,0,0,0,1]],[2,["_euler"],[1,["52FZ4kbjJQ05Bh9aFNRMya"]],[1,0,0,0]],[2,["_lscale"],[1,["52FZ4kbjJQ05Bh9aFNRMya"]],[1,3,3,3]],[16,["_materials","0"],[1,["24LpwU7LJZ3J1i5cPiv3OU"]],39],[6,1,["_shadowCastingMode"],[1,["24LpwU7LJZ3J1i5cPiv3OU"]]],[6,6,["_shadowNormalBias"],[1,["24LpwU7LJZ3J1i5cPiv3OU"]]],[6,5,["_shadowBias"],[1,["24LpwU7LJZ3J1i5cPiv3OU"]]]]],38]],[10,0,{},30,[11,"206WFyActfFYab8VYGP3ll",-169,[28,"76L3eReWpOdJ2+Zd4hd/jq",null,[[6,"HouseA",["_name"],[1,["206WFyActfFYab8VYGP3ll"]]],[2,["_lpos"],[1,["206WFyActfFYab8VYGP3ll"]],[1,49.28,0.608,-18.741]],[2,["_lrot"],[1,["206WFyActfFYab8VYGP3ll"]],[3,0,0.9999961977677758,0,-0.0027576167231126475]],[2,["_euler"],[1,["206WFyActfFYab8VYGP3ll"]],[1,0,-179.684,0]],[2,["_lscale"],[1,["53DFtdNilehYcEyqcOV2cC"]],[1,1,1,1]],[6,1,["_shadowCastingMode"],[1,["049j7gnZVdm5F/bgr6/701"]]],[6,5,["_shadowNormalBias"],[1,["049j7gnZVdm5F/bgr6/701"]]],[6,5,["_shadowBias"],[1,["049j7gnZVdm5F/bgr6/701"]]]]],40]],[10,0,null,30,[11,"27mzaN23VR478JJDBj4b/o",-174,[25,"b4mC76M3BIObxdaB6h1VWz",[[26,"WaterWheel",["_name"],20],[7,["_lpos"],20,[1,87.082,0,59.408]],[7,["_lrot"],20,[3,0,0,0,1]],[7,["_euler"],20,[1,0,0,0]],[7,["_lpos"],-170,[1,0,0,0]],[7,["_lscale"],-171,[1,1,1,1]],[7,["_lscale"],20,[1,3,3,3]],[97,["_materials","0"],-172,42],[16,["_materials","0"],[1,["78y6shdSFbrqfdRih7IyLX"]],43],[26,0,["_shadowCastingMode"],-173]]],41]],[10,0,{},21,[11,"c46/YsCPVOJYA4mWEpNYRx",-175,[28,"e2V/zPloJFgINjg3GmIx6z",null,[[6,"Zoo_0",["_name"],[1,["c46/YsCPVOJYA4mWEpNYRx"]]],[2,["_lpos"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,147.892,0.536,81.122]],[2,["_lrot"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[3,0,0,0,1]],[2,["_euler"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,0,0,0]],[2,["_lscale"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,2,1,2]],[16,["animalPrefab"],[1,["e8kwWA5whP66fh9uQktgCo"]],45]]],44]],[10,0,{},21,[11,"c46/YsCPVOJYA4mWEpNYRx",-176,[25,"dcckVQyiRGNKviME3J/9wR",[[6,"Zoo_1",["_name"],[1,["c46/YsCPVOJYA4mWEpNYRx"]]],[2,["_lpos"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,113.521,2.446,89.333]],[2,["_lrot"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[3,0,0.040280025562922414,0,0.9991884304477561]],[2,["_euler"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,0,4.617,0]],[2,["_lscale"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,2.5,1,2.5]],[16,["animalPrefab"],[1,["e8kwWA5whP66fh9uQktgCo"]],47]]],46]],[10,0,{},21,[11,"c46/YsCPVOJYA4mWEpNYRx",-177,[28,"9fzq65VmBMh7u++6Fd4SX+",null,[[6,"Zoo_2",["_name"],[1,["c46/YsCPVOJYA4mWEpNYRx"]]],[2,["_lpos"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,114.781,2.496,62.854]],[2,["_lrot"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[3,0,0.04360195067784048,0,0.9990489827316212]],[2,["_euler"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,0,4.998,0]],[2,["_lscale"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,2.5,1,2.5]],[16,["animalPrefab"],[1,["e8kwWA5whP66fh9uQktgCo"]],49]]],48]],[10,0,{},21,[11,"c46/YsCPVOJYA4mWEpNYRx",-178,[28,"37firCNN9HJIKvRPzwRfAz",null,[[6,"Zoo_3",["_name"],[1,["c46/YsCPVOJYA4mWEpNYRx"]]],[2,["_lpos"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,120.033,3.506,119.251]],[2,["_lrot"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[3,0,0.11270030738213102,0,0.9936290257012288]],[2,["_euler"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,0,12.942,0]],[2,["_lscale"],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[1,2.2,1,2]],[16,["animalPrefab"],[1,["e8kwWA5whP66fh9uQktgCo"]],51]]],50]],[10,0,null,4,[11,"fcTF/wge1Yj4RHb3yuihdn",-179,[25,"12u2jZBHRMpoewaXT2NgMi",[[7,["_lpos"],31,[1,140.848,4.833,0.038]],[26,"Market",["_name"],31],[7,["_lrot"],31,[3,0,0,0,1]],[7,["_euler"],31,[1,0,0,0]],[7,["_lpos"],32,[1,0,0,0]],[7,["_lscale"],32,[1,1,1,1]],[7,["_lrot"],32,[3,0,0.9990302469546422,0,0.04402914568495296]],[7,["_euler"],32,[1,0,174.953,0]],[16,["_materials","0"],[1,["beJUnU0W5bJpq3/vGbKzub"]],53]]],52]],[61,"Light","c0y6F5f+pAvI805TdmxIjx",4,[[98,true,5027,80000,-180,[4,4293982975],[99,true]]],[1,-6.585,62.99,-8.227],[3,-0.272842620937225,0.6999738317872032,0.6365180069313526,0.1744659447152495],[1,-87.631,143.181,-9.199]],[72,"Camera","c9DMICJLFO5IeO07EPon7U",4,[-181],[1,-179.75,204.867,220.618],[3,-0.27781593346944056,-0.36497167621709875,-0.11507512748638375,0.8811195706053617],[1,-35,-45,0]],[100,0,30,0,2000,1822425087,63],[73,"Camera",3,[-182],[1,0,0,1000]],[101,0,1073741824,320,2000,6,41943040,65,[4,4278190080]],[62,"GardenScene","38Jlngz6tMoaS8CYmRFq8W",4,[[102,-183,[34,35,36],37]]],[1,["c9E10DwfZfGr9iiyNV2Q3b"]],[1,["c2dMW41uRXa4Je62YT7TtT"]]],0,[0,0,1,0,0,1,0,0,1,0,-1,39,0,-2,27,0,-3,7,0,-4,8,0,-5,9,0,-6,10,0,-7,11,0,0,2,0,0,2,0,0,2,0,-1,45,0,-2,28,0,-3,12,0,-4,13,0,-5,14,0,-6,15,0,0,3,0,15,66,0,0,3,0,0,3,0,16,64,0,0,3,0,-1,65,0,-4,5,0,-5,17,0,-1,33,0,-2,34,0,-3,35,0,-4,36,0,-5,37,0,-6,38,0,-7,54,0,-8,55,0,-9,56,0,-10,57,0,-11,58,0,-12,59,0,-13,60,0,-14,61,0,-1,62,0,-2,63,0,-3,6,0,1,4,0,-6,67,0,-7,30,0,-8,21,0,-9,61,0,0,5,0,0,5,0,0,5,0,0,5,0,-1,50,0,-2,29,0,-3,16,0,-1,33,0,-2,34,0,-3,35,0,-4,36,0,-5,37,0,-6,38,0,0,7,0,0,7,0,0,7,0,-1,40,0,0,8,0,0,8,0,0,8,0,-1,41,0,0,9,0,0,9,0,0,9,0,-1,42,0,0,10,0,0,10,0,0,10,0,-1,43,0,0,11,0,0,11,0,0,11,0,-1,44,0,0,12,0,0,12,0,0,12,0,-1,46,0,0,13,0,0,13,0,0,13,0,-1,47,0,0,14,0,0,14,0,0,14,0,-1,48,0,0,15,0,0,15,0,0,15,0,-1,49,0,0,16,0,0,16,0,0,16,0,-1,51,0,0,17,0,0,17,0,-1,18,0,-2,19,0,0,18,0,0,18,0,0,18,0,-1,52,0,0,19,0,0,19,0,0,19,0,-1,53,0,-1,57,0,-2,58,0,-3,59,0,-4,60,0,0,27,0,0,27,0,0,27,0,0,28,0,0,28,0,0,28,0,0,29,0,0,29,0,0,29,0,-1,54,0,-2,55,0,-3,56,0,2,33,0,2,34,0,2,35,0,2,36,0,2,37,0,2,38,0,0,39,0,0,39,0,0,40,0,0,40,0,0,41,0,0,41,0,0,42,0,0,42,0,0,43,0,0,43,0,0,44,0,0,44,0,0,45,0,0,45,0,0,46,0,0,46,0,0,47,0,0,47,0,0,48,0,0,48,0,0,49,0,0,49,0,0,50,0,0,50,0,0,51,0,0,51,0,0,52,0,0,52,0,0,53,0,0,53,0,2,54,0,2,55,0,9,68,0,9,68,0,9,69,0,9,69,0,2,56,0,2,57,0,2,58,0,2,59,0,2,60,0,2,61,0,0,62,0,-1,64,0,-1,66,0,0,67,0,17,4,1,1,3,2,1,3,3,1,4,183],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[3,7,3,7,3,7,3,7,3,7,3,7,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,13,4,13,4,13,4,13,-1,-2,-3,18,3,7,3,3,7,7,3,7,3,7,3,7,3,7,3,7,19,20],[4,0,4,0,4,0,4,0,4,0,4,0,8,5,1,1,1,1,1,8,5,1,1,1,1,8,5,5,1,1,1,1,1,1,35,36,37,38,39,0,40,41,0,0,6,42,6,43,6,44,6,45,46,0,47,48]],[[[17,"Zoo"],[74,"Zoo",[[[63,"AnimalGroup",-4,[0,"f0DM/Q7JdNJ4U4kC1XoaMe",-3,0]],-5],4,1],[[103,null,-2,[8,"e8kwWA5whP66fh9uQktgCo"]]],[0,"c46/YsCPVOJYA4mWEpNYRx",-1,0]],[64,"Plane",1,[[78,"Plane<ModelComponent>",-6,[8,"41c5lpHGJAi4X0AbVHkGDw"],[0],[14],1]],[0,"13jiQkbclGKox916z0n0wn",1,0],[1,0,-1,0]]],0,[0,2,1,0,0,1,0,2,1,0,1,1,0,-2,2,0,0,2,0,5,1,6],[0,0],[-1,6],[0,49]],[[{"name":"progress_bg","rect":{"x":0,"y":0,"width":168,"height":26},"offset":{"x":0,"y":0},"originalSize":{"width":168,"height":26},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-84,-13,0,84,-13,0,-84,13,0,84,13,0],"indexes":[0,1,2,2,1,3],"uv":[0,26,168,26,0,0,168,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-84,"y":-13,"z":0},"maxPos":{"x":84,"y":13,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[50]],[[[15,".bin",1971926032,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":648,"count":324,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":39624,"length":1500,"count":750,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":5256,"length":34368,"count":716,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.736423671245575,-0.015901265665888786,-0.6415857076644897],"maxPosition",8,[1,0.736282467842102,0.2838388681411743,0.6415857076644897]]],-1],0,0,[],[],[]],[[[17,"Pig"],[65,"Pig",[-3,-4],[[40,-2,[8,"86M11R0PxRM4vJ1Drfk534"],[4,5],6]],[0,"c4vk415PFX4Yi9/+2FqzMX",-1,0],[1,0.8,0.8,0.8]],[33,"Body",[-5,-6,-7,-8,-9,-10,-11],[0,"0fQY2FcopXwLigbeSmGelh",1,0],[1,0.0000537765008630231,0.022865893319249153,0.0001363167684758082]],[34,"root",[-12,2,-13,-14,-15],[0,"3bk7FIHv9W+6fSFRQr0pxA",1,0],[3,0.7071068407911908,0,0,0.7071067215818992],[1,90.00000965934633,0,0]],[35,"Armature",1,[3],[0,"31y5NeIo9bz7YazYJATlsR",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[5,"FrontFoot.R",3,[[4,"FrontFoot.R_end",-16,[0,"bfvIWaehJfKZvOfHxr5/hX",1,0],[1,-2.2204459996194763e-18,0.009999999776482582,1.3877787497621727e-19]]],[0,"6eGPBC2J1RqrJ6jzBad5SV",1,0],[1,-0.012202508747577667,0.0010000348556786776,0.01927023008465767],[3,0.7071068407908391,-7.052582993953335e-7,-7.052581857084939e-7,0.7071067215815475],[1,90.00000965934633,4.222240816162296e-13,-0.0001142919905172986]],[3,"FrontLeg.R",2,[-17],[0,"e4p+MrB91Zfa5MRoiZNncU",1,0],[1,-0.004269574768841267,-0.000795309548266232,0.01873094029724598],[3,-0.002626553724746887,0.002626346039806323,0.7071019629827959,0.7071018437735027],[1,-90.00130868452192,90.00129185601334,89.57436459831172]],[3,"FrontUpLeg.R",6,[-18],[0,"0aYj+8hvNYS7uLISzUsEMP",1,0],[1,5.039491046687772e-10,0.008122732862830162,-5.508172806756306e-10],[3,0.7077022123961062,-0.7007208396327973,-0.049289088202437555,0.07562056108054376],[1,99.78124424992761,-70.08242650924606,-87.79254622146254]],[5,"FrontLowLeg.R",7,[[4,"FrontLowLeg.R_end",-19,[0,"c4Uap98nhWq4oOkxrzhoBP",1,0],[1,0,0.00775875011458993,2.2204459996194763e-18]]],[0,"13tMyeS1JVnrMQXDVaLooR",1,0],[1,7.450580430390374e-11,0.013847215101122856,2.94297941572097e-9],[3,0.22962984167916808,-0.018475183996006037,0.004359758872520388,0.9730929019827897],[1,26.555432360062216,-2.175378857743942,-3.6242906981601434e-7]],[3,"BackLeg.R",2,[-20],[0,"84yHMNflNVdJeD4PquI9rv",1,0],[1,-0.004269574768841267,0.000500023365020752,-0.026103053241968155],[3,0.009674674058884796,-0.009675205844083634,0.7070406195401848,0.707040559935539],[1,90.00015494488765,-90.0001980386617,88.43205994202604]],[3,"BackUpLeg.R",9,[-21],[0,"ccDLY5NF1RcLl5vIninFn2",1,0],[1,-8.25720158914578e-10,0.006330168340355158,1.1610342687262687e-9],[3,-0.68285064152525,0.69677917377138,-0.13889586572224363,0.17006387874059534],[1,-53.298047431906234,101.45639533242752,-87.23352682389415]],[5,"BackLowLeg.R",10,[[4,"BackLowLeg.R_end",-22,[0,"26mQPFXa1QHbIFloTsdsUW",1,0],[1,-2.2204459996194763e-18,0.009370130486786366,-4.440891999238953e-18]]],[0,"d0KXIUmSRe87aIhFZg+LXO",1,0],[1,2.7939680083410856e-11,0.014889427460730076,-5.587935447692871e-9],[3,-0.3504077745177412,0.018124229962963857,0.006782150270737208,0.9363973015144152],[1,-41.032546532043696,2.217670963562338,-0.00000961127377546852]],[3,"FrontLeg.L",2,[-23],[0,"aaMgLpbmRQNqH245i6hjfh",1,0],[1,0.0036532492376863956,-0.000795309548266232,0.01873094029724598],[3,0.7071024039694828,0.7071025231787699,-0.0024711372773669614,0.002470930058098205],[1,89.99862634439606,90.00139044636622,89.59955103764257]],[3,"FrontUpLeg.L",12,[-24],[0,"2fo+inIwZT8pjE+3wZm7RB",1,0],[1,2.644426899678365e-10,0.008122734725475311,-7.52725659580733e-10],[3,-0.02583532208881628,-0.09908143382113105,0.7089457476959412,0.6977903212486962],[1,93.58513783100715,-103.73413368851504,83.99379184091082]],[5,"FrontLowLeg.L",13,[[4,"FrontLowLeg.L_end",-25,[0,"e6Jfi09ItXb4d6ivH9ilYf",1,0],[1,0,0.00775875011458993,0]]],[0,"c41arLnUlXe7i+AX0nsLZz",1,0],[1,-2.60770322002557e-10,0.01384721603244543,4.172325152040912e-9],[3,0.22935618360327673,0.05088980473774733,-0.012008825264744508,0.971937115729436],[1,26.55532961486697,5.994441306155325,0.000007838962309451546]],[3,"BackLeg.L",2,[-26],[0,"65D7EOrXhc2L4V4K+FH/DH",1,0],[1,0.0036532492376863956,0.000500023365020752,-0.026103053241968155],[3,0.7070432849012058,0.7070433445058502,0.00947344109849652,-0.009473973815005254],[1,-89.99979817480195,-90.00015865612107,88.46467405363576]],[3,"BackUpLeg.L",15,[-27],[0,"05HYD744xXB7uSUKYXBiC6",1,0],[1,3.629850864328432e-9,0.0063301692716777325,-9.270575973552297e-10],[3,0.14581188407120652,0.16338796742840697,0.6814084577861013,0.6983736680465451],[1,-33.38226338967248,58.64411132034426,88.02052174028046]],[5,"BackLowLeg.L",16,[[4,"BackLowLeg.L_end",-28,[0,"d5tLsfvTtaf7kJlGej9MkS",1,0],[1,0,0.009370130486786366,4.440891999238953e-18]]],[0,"05r4fATC5dBIKO2aN1cLkl",1,0],[1,2.98023217215615e-10,0.014889421872794628,-1.6018748549839756e-9],[3,-0.3504568944604175,-0.008899991426350643,-0.0033305306084184865,0.9365306523780401],[1,-41.032462974424355,-1.088951471515277,-0.000009241518632200168]],[5,"Back",2,[[4,"Back_end",-29,[0,"16TAw99YlVB7DF2pxvWXiS",1,0],[1,1.3877787497621727e-19,0.009700956754386425,0]]],[0,"a9+nVcL6xU07aQOvoFaq10",1,0],[1,-0.00032282702159136534,0.00543849216774106,-0.03082328476011753],[3,0.6013810784421046,0.01280548548560241,0.0019118771200423712,0.7988574107806519],[1,73.93537399778333,1.0407247311152548,1.0575446296570528]],[3,"Shoulders",2,[-30],[0,"6e0JRFEe1TeY6ggAQV1jlq",1,0],[1,-0.0007365463534370065,0.0021116279531270266,0.007024262100458145],[3,0.009116792300720765,0.7548107058390505,0.6555643211588165,-0.020324942127349012],[1,-81.9338527721709,-177.55617875845968,-0.7383171696271522]],[3,"Neck",19,[-31],[0,"26r05lVOdavrh3rrCrTlsI",1,0],[1,5.587935322792781e-11,0.01023773942142725,9.901123254607569e-10],[3,0.06568982530301817,-0.010677165478828575,-0.019551655510205372,0.9975913881724355],[1,7.5130789369976725,-1.074331509022261,-2.3160613517828006]],[5,"Head",20,[[4,"Head_end",-32,[0,"b9yTX971haf6FBRNyW/1Y6",1,0],[1,0,0.016001464799046516,4.440891999238953e-18]]],[0,"7enRWHSvlUW55kpXtRw629",1,0],[1,-1.374246463153872e-11,0.01546743605285883,-7.917883015906568e-10],[3,-0.3912635084935673,-0.23469923060920597,0.08755992957849183,0.8855294443466917],[1,-43.852722466307604,-21.651494074236194,19.79965655638713]],[3,"Hips",2,[-33],[0,"dbyWueyE1YorW3e955uqOC",1,0],[1,-0.00032282702159136534,0.008262631483376026,-0.021542511880397797],[3,0.0000036929936965009404,0.6548693197189831,0.7557421346377732,0.0000032093501060601146],[1,-98.18051634496828,-179.99992101822417,0.000555066542802596]],[5,"Torso",22,[[4,"Torso_end",-34,[0,"68CbxLQdxW2I6JX8FULj+9",1,0],[1,-2.081668124643259e-19,0.015270233154296875,0]]],[0,"0fE6Odj1NcWriRUibjKg+l",1,0],[1,3.676632349264297e-12,0.017321430146694183,-1.7496742943379218e-9],[3,0.10717273693362754,0.0014853627916875047,-0.01346725528698138,0.9941480931886193],[1,12.310286342992873,0.33472565925775755,-1.5161379744604435]],[5,"BackFoot.R",3,[[4,"BackFoot.R_end",-35,[0,"4aOWxxSLpTMatIN2mfNU+z",1,0],[1,-2.2204459996194763e-18,0.006745369639247656,1.3877787497621727e-19]]],[0,"d0U2i3uKNVJqnAuo5TeXAT",1,0],[1,-0.01117923017591238,0.0010000348556786776,-0.030364982783794403],[3,0.7071068407907499,-7.89552088787537e-7,-7.895519751006974e-7,0.7071067215814584],[1,90.00000965934632,1.5737091652577643e-12,-0.00012795238382659827]],[5,"FrontFoot.L",3,[[4,"FrontFoot.L_end",-36,[0,"32Qv1VeHla8YlfVBERQork",1,0],[1,-2.2204459996194763e-18,0.009999999776482582,1.3877787497621727e-19]]],[0,"d4F0TZqhRdNqi13VpqMmng",1,0],[1,0.011693737469613552,0.0010000348556786776,0.01927023008465767],[3,0.7071068407904224,-0.0000010424331727468324,-0.0000010424330590599927,0.7071067215811309],[1,90.00000965934633,5.0281604972794496e-12,-0.0001689335176951215]],[5,"BackFoot.L",3,[[4,"BackFoot.L_end",-37,[0,"58cb/fgSdQPIckaCG5vjUZ",1,0],[1,0,0.006745369639247656,0]]],[0,"5awspJ6fRY+rbK9y/T0xqO",1,0],[1,0.010670462623238564,0.0010000348556786776,-0.030364982783794403],[3,0.7071068407902931,-0.0000011267269621388797,-0.0000011267267347652002,0.7071067215810014],[1,90.0000096593463,-3.0322257095313997e-12,-0.00018259390179253452]],[36,"Pig",1,[[41,-38,[8,"f2VoOSITtT24+SBPYJ39Ru"],[0,1],[14],1,2,3]],[0,"4a7A2OcWxQtKiPBFQm6ri/",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]]],0,[0,2,1,0,0,1,0,-1,4,0,-2,27,0,-1,6,0,-2,9,0,-3,12,0,-4,15,0,-5,18,0,-6,19,0,-7,22,0,-1,5,0,-3,24,0,-4,25,0,-5,26,0,1,5,0,-1,7,0,-1,8,0,1,8,0,-1,10,0,-1,11,0,1,11,0,-1,13,0,-1,14,0,1,14,0,-1,16,0,-1,17,0,1,17,0,1,18,0,-1,20,0,-1,21,0,1,21,0,-1,23,0,1,23,0,1,24,0,1,25,0,1,26,0,0,27,0,5,1,2,1,3,3,1,4,38],[0,0,0,0,0,0,0],[-1,-2,6,11,-1,-2,12],[51,52,53,54,13,55,13]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@e9a6d","back":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@40c10","left":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@8fd34","right":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@74afd","top":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@bb97f","bottom":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@7d38f"}]}],[8],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"name":"bg_popup","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[15,16,15,15],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[56]],[[[17,"Sheep"],[29,"Sheep",[-3,-4],[[40,-2,[8,"61/GCmGrReIrR0eym1NaFf"],[4,5],6]],[0,"82GNMKXo1T0Y1rFdvsRGPM",-1,0]],[33,"Body",[-5,-6,-7,-8,-9,-10,-11],[0,"d1A4I8AUdT0YRr5gKoBWe/",1,0],[1,0.0000537765008630231,0.023020822554826736,-0.00017354160081595182]],[34,"root",[-12,2,-13,-14,-15],[0,"02SvaUKdteJLXZ66B2b2FP",1,0],[3,0.7071068407911908,0,0,0.7071067215818992],[1,90.00000965934633,0,0]],[35,"Armature",1,[3],[0,"a52TLuzUhVA6ik6B5NVrOM",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[5,"FrontFoot.R",3,[[4,"FrontFoot.R_end",-16,[0,"2aUFlTscNZwZAevCnSPV8y",1,0],[1,0,0.009999999776482582,1.3877787497621727e-19]]],[0,"070i/BvXZdYbRneCbJxSwL",1,0],[1,-0.009117710404098034,0.0010000348556786776,0.011625418439507484],[3,0.7071068407908391,-7.052582993953335e-7,-7.052581857084939e-7,0.7071067215815475],[1,90.00000965934633,4.222240816162296e-13,-0.0001142919905172986]],[3,"FrontLeg.R",2,[-17],[0,"c57Wofwz1VhZrW/jUfK7CL",1,0],[1,-0.0032468067947775126,0.0007351660751737654,0.011086128652095795],[3,0.001759224685003861,-0.001759504431021782,0.7071046222328422,0.7071045626281975],[1,90.00095921400722,-90.0009818814695,89.71488247460297]],[3,"FrontUpLeg.R",6,[-18],[0,"5d40lYkc5Y+pMajMPkpFx5",1,0],[1,-1.169286445446005e-9,0.006025583017617464,-1.0463159227924734e-9],[3,0.7063969929174672,-0.7005700428776944,-0.05700322580377962,0.0833998541213886],[1,96.74942732227163,-71.85306452936813,-87.80949558096775]],[5,"FrontLowLeg.R",7,[[4,"FrontLowLeg.R_end",-19,[0,"4durxqbiNXALKYfFnhuGHP",1,0],[1,0,0.010788065381348133,0]]],[0,"9ee34HeJ9f4I+Jr69phZqg",1,0],[1,-8.940696516468449e-10,0.012328616343438625,-1.0058284205527457e-9],[3,0.17354831188320954,-0.01869456293314814,0.003295097749778646,0.9846423914752231],[1,19.992019289150353,-2.175392235297918,0.000009521417726256196]],[3,"BackLeg.R",2,[-20],[0,"5b1wUALBpWe7e3dvm+3Zlj",1,0],[1,-0.0032468067947775126,0.0007351660751737654,-0.012089414522051811],[3,0.0011415672713054855,-0.001142285437439962,0.7071058889239055,0.7071058293192596],[1,90.00146622576744,-90.00152441774468,89.81494283233243]],[3,"BackUpLeg.R",9,[-21],[0,"980jA5v/FXAoDOIWYZhHp/",1,0],[1,1.9162351705404035e-9,0.004695830401033163,4.313415180590141e-10],[3,-0.6694069546802774,0.6761872810893089,-0.2015373719482051,0.23248177912889348],[1,-59.76403896514078,84.481923642685,-87.43292265176157]],[5,"BackLowLeg.R",10,[[4,"BackLowLeg.R_end",-22,[0,"0e8Zkx6sxWor88muDlOEON",1,0],[1,-1.1102229998097382e-18,0.014139310456812382,2.2204459996194763e-18]]],[0,"a2iae7CjlVf49BU2vh66Mi",1,0],[1,-5.494802945982258e-10,0.010874387808144093,2.197921178392903e-9],[3,-0.3844085127350388,0.017864142029827695,0.0074402333109610105,0.922960243290388],[1,-45.22298682072363,2.217669092408485,-0.00001016680968784006]],[3,"FrontLeg.L",2,[-23],[0,"49TcaXY3tYx7JsEW3AXcCG",1,0],[1,0.002630481729283929,0.0007351660751737654,0.011086128652095795],[3,0.7071042882147346,0.7071043478193813,0.0018662580417783889,-0.0018665380206363013],[1,-89.99907376766035,-90.00090354600064,89.69753690076666]],[3,"FrontUpLeg.L",12,[-24],[0,"06nOfNLYlZ97oITm7fnYha",1,0],[1,1.820303019428593e-9,0.006025584880262613,2.9767932563373734e-10],[3,-0.03354005532296625,-0.10680354439814407,0.7078987991338975,0.6973860894638723],[1,92.46260546130135,-103.86886434449062,84.0000267138086]],[5,"FrontLowLeg.L",13,[[4,"FrontLowLeg.L_end",-25,[0,"acR6tKgllS+Idzo1L8R/SH",1,0],[1,-1.1102229998097382e-18,0.010788065381348133,0]]],[0,"31BoYbr6hQKqz0MRBjd5nD",1,0],[1,-9.126961408867373e-10,0.012328613549470901,2.2351742678949904e-10],[3,0.17334077882030413,0.05149381497771455,-0.009075931079523604,0.9834729222973306],[1,19.991859713453287,5.994442837345826,0.0000052175046496013526]],[3,"BackLeg.L",2,[-26],[0,"bc8r+ZQJ9T0px/xKS/SdR/",1,0],[1,0.002630481729283929,0.0007351660751737654,-0.012089414522051811],[3,0.7071060657659742,0.70710612537062,0.0009843286991510216,-0.0009850468652834953],[1,-89.99823680378105,-90.00170500426317,89.84042446255556]],[3,"BackUpLeg.L",15,[-27],[0,"4ex8UAAuheMq3W765aS1ha",1,0],[1,7.193722839637928e-10,0.004695831332355738,-4.113587803722396e-10],[3,0.20827126666144127,0.22595982430561568,0.667343502504073,0.6783936076855459],[1,-40.12341711255629,75.89024608267604,88.30997566191499]],[5,"BackLowLeg.L",16,[[4,"BackLowLeg.L_end",-28,[0,"7c8R++QsFUaZaJVZMJXr/y",1,0],[1,0,0.014139310456812382,-2.2204459996194763e-18]]],[0,"adobIJWF5Zw7y4gypp53yM",1,0],[1,9.499490083442197e-10,0.010874386876821518,5.671754621516811e-9],[3,-0.38446301706204034,-0.008772295078882275,-0.0036537223955848443,0.9230914828245673],[1,-45.22297058747652,-1.0889548889368428,-0.000011114393924774482]],[5,"Back",2,[[4,"Back_end",-29,[0,"c6m9jWnv1RVZ6/Zak8SBNY",1,0],[1,0,0.009700954891741276,0]]],[0,"88/AcAdSJYcKyJILKdrOCi",1,0],[1,-0.0003228271089028567,0.005012156907469034,-0.020330894738435745],[3,0.6012591021672216,0.022893471255302226,-0.005923485748654215,0.7987041338014566],[1,73.92174385120882,2.504649153423718,1.0352530304321572]],[3,"Shoulders",2,[-30],[0,"30e5bKhilT3omx8kIIF+qY",1,0],[1,-0.0006895044934935868,0.003097136039286852,0.010320519097149372],[3,0.006586595858524795,0.9146405991234157,0.40345903952012446,-0.024698069148300767],[1,-47.594305221915135,-177.10555420477104,-0.451528793819739]],[3,"Neck",19,[-31],[0,"b0IQOTnTJTz5PCcH71wv56",1,0],[1,-3.725290215195187e-11,0.009995866566896439,1.931330206872417e-9],[3,0.07927492803181278,-0.02114728784104056,-0.014362238911422593,0.9965249641107693],[1,9.0601911246174,-2.2861851106598774,-1.8324915484586781]],[5,"Head",20,[[4,"Head_end",-32,[0,"96OLJJldpRnajNlqrO5KpD",1,0],[1,0,0.013046626932919025,0]]],[0,"9bzWLUv2hchIGHeVPI5205",1,0],[1,-6.502887204412611e-12,0.009685486555099487,-3.4133518234114035e-9],[3,-0.6495658751193727,-0.1919835655666978,0.17329835880761985,0.7149644489534334],[1,-83.64317230978557,-3.263048642395457,29.816000613815135]],[3,"Hips",2,[-33],[0,"d6pAFkxtJdxapiusFehd1n",1,0],[1,-0.0003228271089028567,0.007836296223104,-0.011050121858716011],[3,0.000003487624764492713,0.6944211092559098,0.719568845209615,0.0000033658895813566903],[1,-92.03778993215424,-179.99998026259544,0.0005550665619484873]],[5,"Torso",22,[[4,"Torso_end",-34,[0,"1dmnpOXmNck7aYNeic7ags",1,0],[1,1.5612511904176723e-19,0.011592737399041653,4.440891999238953e-18]]],[0,"468AyXGmtTB4t5bH3C5hpO",1,0],[1,2.3564155834931988e-11,0.01467173546552658,1.0163526686923774e-9],[3,0.06518349789635298,0.0008379450291840548,-0.017830681036914243,0.9977136243751932],[1,7.480036142222443,0.22913257622433084,-2.0327413044171383]],[5,"BackFoot.R",3,[[4,"BackFoot.R_end",-35,[0,"c5L6bFM0tStar8Mq5a2m7j",1,0],[1,0,0.006745369639247656,0]]],[0,"74u3lt7adaO6eIweYTWfwJ",1,0],[1,-0.008358624763786793,0.0010000348556786776,-0.01635134406387806],[3,0.7071068407908391,-7.052582993953335e-7,-7.052581857084939e-7,0.7071067215815475],[1,90.00000965934633,4.222240816162296e-13,-0.0001142919905172986]],[5,"FrontFoot.L",3,[[4,"FrontFoot.L_end",-36,[0,"20hek8PlBWs768idPWUg2H",1,0],[1,1.1102229998097382e-18,0.009999999776482582,2.7755574995243454e-19]]],[0,"a2jAo6kFZZUob0in3TCs/x",1,0],[1,0.008608940057456493,0.0010000348556786776,0.011625418439507484],[3,0.7071068407904224,-0.0000010424331727468324,-0.0000010424330590599927,0.7071067215811309],[1,90.00000965934633,5.0281604972794496e-12,-0.0001689335176951215]],[5,"BackFoot.L",3,[[4,"BackFoot.L_end",-37,[0,"1eJykJvUtY0IAMxXqhbKoq",1,0],[1,1.1102229998097382e-18,0.006745369639247656,1.3877787497621727e-19]]],[0,"6bn5Dh4p5aUIP4MvJjdSF1",1,0],[1,0.007849856279790401,0.0010000348556786776,-0.01635134406387806],[3,0.7071068407904224,-0.0000010424331727468324,-0.0000010424330590599927,0.7071067215811309],[1,90.00000965934633,5.0281604972794496e-12,-0.0001689335176951215]],[36,"Sheep",1,[[41,-38,[8,"2fhpznXbJZZZkVBCqHDYmt"],[0,1],[14],1,2,3]],[0,"1c8OGYxUxQGLHAe9qcT9Vs",1,0],[3,0.9999999999999971,1.1102232893229494e-16,-1.1102230246251533e-16,7.549790126404311e-8],[1,65.45861053466797,65.45861053466797,65.45861053466797],[1,179.9999913485778,1.2722219686355036e-14,1.2722220798566492e-14]]],0,[0,2,1,0,0,1,0,-1,4,0,-2,27,0,-1,6,0,-2,9,0,-3,12,0,-4,15,0,-5,18,0,-6,19,0,-7,22,0,-1,5,0,-3,24,0,-4,25,0,-5,26,0,1,5,0,-1,7,0,-1,8,0,1,8,0,-1,10,0,-1,11,0,1,11,0,-1,13,0,-1,14,0,1,14,0,-1,16,0,-1,17,0,1,17,0,1,18,0,-1,20,0,-1,21,0,1,21,0,-1,23,0,1,23,0,1,24,0,1,25,0,1,26,0,0,27,0,5,1,2,1,3,3,1,4,38],[0,0,0,0,0,0,0],[-1,-2,6,11,-1,-2,12],[57,58,59,60,14,61,14]],[[[42,"Skin-0",1676884100,["Armature/root","Armature/root/FrontFoot.R","Armature/root/Body","Armature/root/Body/FrontLeg.R","Armature/root/Body/FrontLeg.R/FrontUpLeg.R","Armature/root/Body/FrontLeg.R/FrontUpLeg.R/FrontLowLeg.R","Armature/root/Body/BackLeg.R","Armature/root/Body/BackLeg.R/BackUpLeg.R","Armature/root/Body/BackLeg.R/BackUpLeg.R/BackLowLeg.R","Armature/root/Body/FrontLeg.L","Armature/root/Body/FrontLeg.L/FrontUpLeg.L","Armature/root/Body/FrontLeg.L/FrontUpLeg.L/FrontLowLeg.L","Armature/root/Body/BackLeg.L","Armature/root/Body/BackLeg.L/BackUpLeg.L","Armature/root/Body/BackLeg.L/BackUpLeg.L/BackLowLeg.L","Armature/root/Body/Back","Armature/root/Body/Shoulders","Armature/root/Body/Shoulders/Neck","Armature/root/Body/Shoulders/Neck/Head","Armature/root/Body/Hips","Armature/root/Body/Hips/Torso","Armature/root/BackFoot.R","Armature/root/FrontFoot.L","Armature/root/BackFoot.L"],[[[7,1,0,0,0,0,6.123234262925839e-17,-1,0,0,1,6.123234262925839e-17,0,0,0,0,1],[7,1,1.221445088829075e-22,-0.000001994771309909993,0,-1.221445088829075e-22,-1,-1.2246468525851679e-16,0,-0.000001994771309909993,1.2246468525851679e-16,-1,0,0.012202510610222816,-0.01927023008465767,0.001000010408461094,1],[7,1,0,0,0,0,6.123234262925839e-17,-1,0,0,1,6.123234262925839e-17,0,-0.0000537765008630231,-0.023020826280117035,0.00017354160081595182,1],[7,-2.902661292748798e-14,-1,-2.935201734999282e-7,0,1.9470718370939721e-7,2.935201734999282e-7,-1,0,1,-8.617709817233463e-14,1.9470718370939721e-7,0,-0.022225508466362953,-0.004215793218463659,-0.018557405099272728,1],[7,0.9992793202400208,-3.659940617239954e-8,0.03795874863862991,0,-0.037367112934589386,-0.17586931586265564,0.9837040901184082,0,0.006675743032246828,-0.9844135642051697,-0.17574256658554077,0,0.011487830430269241,0.018615419045090675,0.022629311308264732,1],[7,1,-1.585666531411789e-8,2.480254295278428e-7,0,-2.39512019106769e-7,0.20492984354496002,0.9787766337394714,0,-6.634795113313885e-8,-0.9787766337394714,0.20492984354496002,0,0.012338528409600258,0.012713761068880558,0.018785972148180008,1],[7,-4.207132960152432e-13,-1,-7.532771633123048e-7,0,1.9470718370939721e-7,7.532771633123048e-7,-1,0,1,-5.673817535592485e-13,1.9470718370939721e-7,0,-0.023520853370428085,-0.004215818364173174,0.026276588439941406,1],[7,0.9992510080337524,4.943616183084032e-9,-0.038695961236953735,0,0.0349908173084259,0.42700377106666565,0.903572678565979,0,0.016523325815796852,-0.9042498469352722,0.4266839623451233,0,0.009229985997080803,0.010048515163362026,-0.034186869859695435,1],[7,1.0000001192092896,1.9992134170365716e-8,2.294946028769118e-7,0,-2.1670182093203039e-7,-0.25633805990219116,0.9665873050689697,0,7.815235392172326e-8,-0.9665871858596802,-0.25633808970451355,0,0.010545974597334862,0.018086502328515053,-0.028966011479496956,1],[7,-5.833650077759212e-14,1,-2.935200882347999e-7,0,-9.589427918399451e-8,2.935200882347999e-7,1,0,1,8.648339883858894e-14,9.589427918399451e-8,0,-0.0222255140542984,-0.0037070203106850386,0.01855739764869213,1],[7,0.9945321083068848,9.479165186121463e-8,-0.10443174839019775,0,0.1028040423989296,-0.17586933076381683,0.9790306687355042,0,-0.0183662511408329,-0.9844136238098145,-0.17490769922733307,0,-0.009449101984500885,0.018615419045090675,0.023291079327464104,1],[7,1,1.2028807816477638e-7,2.224404909156874e-7,0,-2.4237021989392815e-7,0.20492982864379883,0.9787766337394714,0,7.215046338160391e-8,-0.9787766933441162,0.20492978394031525,0,-0.011829766444861889,0.012713762931525707,0.01878596656024456,1],[7,-4.822196244744226e-13,1,-7.532769927820482e-7,0,-1.1297453283987124e-7,7.532769927820482e-7,1,0,1,5.673207671870462e-13,1.1297453283987124e-7,0,-0.02352084219455719,-0.0037070452235639095,-0.026276597753167152,1],[7,0.9998193979263306,1.729508447567696e-8,0.01900491863489151,0,-0.01718520186841488,0.42700377106666565,0.9040865898132324,0,-0.00811515562236309,-0.9042497873306274,0.4269266426563263,0,-0.009392938576638699,0.010048513300716877,-0.03398875147104263,1],[7,1.0000001192092896,-3.829617867268098e-8,3.0222182090255956e-7,0,-3.0194053124432685e-7,-0.25633829832077026,0.9665871262550354,0,4.045443091627021e-8,-0.9665871858596802,-0.2563382387161255,0,-0.010037186555564404,0.0180865116417408,-0.028966011479496956,1],[7,1.0000001192092896,2.2545648751788952e-14,4.7683710135970614e-7,0,1.3881681582006422e-7,-0.9566866755485535,-0.2911199927330017,0,4.561836419725296e-7,0.2911199927330017,-0.9566866755485535,0,0.0002690332767087966,0.021369177848100662,0.03625044226646423,1],[7,-0.9990076422691345,0.040411219000816345,-0.01872910000383854,0,-0.04263587296009064,-0.9892835021018982,0.13964474201202393,0,-0.012885171920061111,0.14030469954013824,0.9900245666503906,0,-0.000650342961307615,-0.010275914333760738,-0.02393786422908306,1],[7,-0.9999998807907104,6.3928204951935186e-9,0.000005154064183443552,0,0.0000013785896726403735,-0.9632322192192078,0.26867103576660156,0,0.0000049662762648949865,0.26867106556892395,0.9632320404052734,0,-0.00026915912167169154,-0.023492753505706787,-0.02103027142584324,1],[7,-0.8661967515945435,-0.0017019043443724513,0.49970006942749023,0,-0.2609688341617584,-0.8512482047080994,-0.45527133345603943,0,0.4261435270309448,-0.5247607231140137,0.7369042038917542,0,-0.02164512686431408,-0.01101308036595583,-0.03701946884393692,1],[7,-1,1.370309573277273e-12,0.000009687740202934947,0,-0.0000013784924703941215,-0.9898243546485901,-0.142292320728302,0,0.000009589163710188586,-0.14229227602481842,0.989824652671814,0,-0.00026932056061923504,0.025946469977498055,-0.027875103056430817,1],[7,-0.9996329545974731,-0.027093209326267242,-0.00005722458445234224,0,0.02701890468597412,-0.9970427751541138,0.07193955779075623,0,-0.002006129128858447,0.07191158086061478,0.9974090456962585,0,-0.0003346375306136906,0.0024776593782007694,-0.029072916135191917,1],[7,1,1.367434464739662e-22,-0.0000022331898890115554,0,-1.367434464739662e-22,-1,-1.2246468525851679e-16,0,-0.0000022331898890115554,1.2246468525851679e-16,-1,0,0.011179232969880104,0.030364984646439552,0.0010000098263844848,1],[7,1,1.8054022138181879e-22,-0.000002948445626316243,0,-1.8054022138181879e-22,-1,-1.2246468525851679e-16,0,-0.000002948445626316243,1.2246468525851679e-16,-1,0,-0.011693734675645828,-0.01927023008465767,0.0010000691981986165,1],[7,1,1.9513914635110298e-22,-0.0000031868642054178054,0,-1.9513914635110298e-22,-1,-1.2246468525851679e-16,0,-0.0000031868642054178054,1.2246468525851679e-16,-1,0,-0.010670460760593414,0.030364984646439552,0.0010000687325373292,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[15,".bin",85728825,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":68992,"length":6264,"count":1566,"stride":4}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[1],"indexView":{"offset":80376,"length":480,"count":120,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":68992,"count":1078,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":75256,"length":5120,"count":80,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]]},"minPosition",8,[1,-0.016555821523070335,-0.051976002752780914,-0.000015856254321988672],"maxPosition",8,[1,0.016555821523070335,0.045862454921007156,0.04588065296411514]]],-1],0,0,[],[],[]],[[[24,"Material.003",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":9.607843137254903,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4288979416],"emissive",8,[4,4288979416]]],11]]],0,0,[0],[8],[2]],[[[24,"Material",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true}],[[[{"shininessExponent":9.607843137254903,"emissiveScale":0,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282274684],"emissive",8,[4,4282274684]]],11]]],0,0,[0],[8],[2]],[[[17,"farm_plot_null"],[66,"farm_plot_null",[-2],[0,"a3/CqMcipbNZWJptIpe6/F",-1,0],[1,9.361,-0.403,8.351],[3,0,0.7071067811865475,0,0.7071067811865476],[1,10,10,10],[1,0,90,0]],[30,"farm_plot",1,[[21,-3,[8,"a1RWhhznVfRrhgZTGNnBmD"],[0,1],[14],2]],[0,"6aRJkT3KFaOp7SHJ26xkQK",1,0]]],0,[0,2,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,6],[0,11,62]],[[[17,"wheat_2"],[53,"wheat_2",[-2],[0,"74gGhvqp1fzIEFLpVvPdM5",-1,0],[1,2,2,2]],[30,"Sphere001",1,[[21,-3,[8,"25U7C03lNWYIuFpE1guGbw"],[0],[14],1]],[0,"b39i51Ey5SiaMnzMt9zrev",1,0]]],0,[0,2,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,6],[0,63]],[[[17,"Land"],[29,"Land",[-14,-15,-16,-17],[[104,-13,[8,"7f8/x3K65Jtop02EyKrnCj"]]],[77,"c46/YsCPVOJYA4mWEpNYRx",-12,0,[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11]]],[67,"blocks",1,[-18,-19,-20,-21,-22,-23,-24,-25,-26],[0,"34UlZlfZ9JAonxQNwEVkgb",1,0],[1,0,0.2,0]],[68,"RenderRoot2D",false,1,[-29],[[43,-27,[8,"5evCnRHaVApZQiDzQImiJ9"]],[56,-28,[8,"51kSYC3ENFQ44QQkhtp9uY"]]],[0,"77sS0FYT9Oi5maUtqiA0oi",1,0]],[10,0,null,1,[11,"047WPd4YhflLipehZ6gK4y",-30,[20,"576lfe1v9F1ov82MXrSknR",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,-3.896,0.39,-4.338]],[6,"SelectingBlock",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,12.5,10,13.5]],[6,false,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,0,0,0]],[2,["_lscale"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,1,1,1]],[16,["_materials","0"],[1,["b8jH+yTS1ZlK/kjb3wvwLp"]],1]]],0]],[10,0,null,2,[11,"047WPd4YhflLipehZ6gK4y",-33,[20,"f9gQIKpClP750zyAB56Hy4",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,-4,0.2,-4.338]],[6,"block_0",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[6,true,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[7,["_lpos"],-31,[1,0,0,0]],[7,["_lscale"],-32,[1,1,1,1]]]],2]],[10,0,null,2,[11,"047WPd4YhflLipehZ6gK4y",-34,[20,"44bjZ4fIlKRpj1oq5Gnjid",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,-0.09,0.2,-4.338]],[6,"block_1",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[6,true,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,-0.002,0,0]],[2,["_lscale"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,1,1,1]]]],3]],[10,0,null,2,[11,"047WPd4YhflLipehZ6gK4y",-37,[20,"a0FOOcjpRKMYmNdiq1Ouzs",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,3.742,0.2,-4.338]],[6,"block_2",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[6,true,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[7,["_lpos"],-35,[1,0,0,0]],[7,["_lscale"],-36,[1,1,1,1]]]],4]],[10,0,null,2,[11,"047WPd4YhflLipehZ6gK4y",-40,[20,"20VyLy7ZlE9qpKWzSdjwSA",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,-4,0.2,-0.166]],[6,"block_3",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[6,true,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[7,["_lpos"],-38,[1,0,0,0]],[7,["_lscale"],-39,[1,1,1,1]]]],5]],[10,0,null,2,[11,"047WPd4YhflLipehZ6gK4y",-41,[20,"8ca4RKGWBMKKuqZBugtGYD",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,-0.09,0.2,-0.166]],[6,"block_4",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[6,true,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,-0.002,0,0]],[2,["_lscale"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,1,1,1]]]],6]],[10,0,null,2,[11,"047WPd4YhflLipehZ6gK4y",-42,[20,"c7KhTQHetB779S+5B4Mlbk",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,3.742,0.2,-0.166]],[6,"block_5",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[6,true,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,0,0,0]],[2,["_lscale"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,1,1,1]]]],7]],[10,0,null,2,[11,"047WPd4YhflLipehZ6gK4y",-45,[20,"a9nIhan+5I2Ymbqlu4p77m",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,-4,0.2,3.847]],[6,"block_6",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[6,true,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[7,["_lpos"],-43,[1,0,0,0]],[7,["_lscale"],-44,[1,1,1,1]]]],8]],[10,0,null,2,[11,"047WPd4YhflLipehZ6gK4y",-46,[20,"cbj5l0bbREL6P1VHH3uZBt",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,-0.09,0.2,3.847]],[6,"block_7",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[6,true,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,-0.002,0,0]],[2,["_lscale"],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,1,1,1]]]],9]],[10,0,null,2,[11,"047WPd4YhflLipehZ6gK4y",-49,[20,"aeUc3oTFlLGYutA1iYeFdq",1,[[2,["_lpos"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,3.742,0.2,3.847]],[6,"block_8",["_name"],[1,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lrot"],[1,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[2,["_euler"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[2,["_lscale"],[1,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[6,true,["_active"],[1,["047WPd4YhflLipehZ6gK4y"]]],[7,["_lpos"],-47,[1,0,0,0]],[7,["_lscale"],-48,[1,1,1,1]]]],10]],[10,0,{},1,[11,"a3/CqMcipbNZWJptIpe6/F",-50,[20,"4fV5cw7A9JPr8g1JqKJnM0",1,[[6,"Plane",["_name"],[1,["a3/CqMcipbNZWJptIpe6/F"]]],[2,["_lpos"],[1,["a3/CqMcipbNZWJptIpe6/F"]],[1,-0.185,0,-0.231]],[2,["_lrot"],[1,["a3/CqMcipbNZWJptIpe6/F"]],[3,0,0.7071067811865475,0,0.7071067811865476]],[2,["_euler"],[1,["a3/CqMcipbNZWJptIpe6/F"]],[1,0,90,0]],[2,["_lscale"],[1,["a3/CqMcipbNZWJptIpe6/F"]],[1,10,10,10]],[6,true,["_active"],[1,["a3/CqMcipbNZWJptIpe6/F"]]]]],11]],[47,"Label",33554432,3,[[48,-51,[8,"0e5N2B1ZtEvqspNJdQNdaL"],[5,54.82,50.4]],[55,"Locked",17,17,-52,[8,"51db0RUahOGrP72G37EwTx"]]],[0,"f8CmZgaxhJHJbGqc8SFy2j",1,0]],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,["4bxf/9yPpVMZGAn0aI9L/H"]]],0,[0,-1,14,0,-2,13,0,-3,12,0,-4,11,0,-5,10,0,-6,9,0,-7,8,0,-8,7,0,-9,6,0,-10,5,0,-11,4,0,2,1,0,0,1,0,-1,4,0,-2,2,0,-3,14,0,-4,3,0,-1,5,0,-2,6,0,-3,7,0,-4,8,0,-5,9,0,-6,10,0,-7,11,0,-8,12,0,-9,13,0,0,3,0,0,3,0,-1,15,0,2,4,0,9,16,0,9,16,0,2,5,0,2,6,0,9,17,0,9,17,0,2,7,0,9,18,0,9,18,0,2,8,0,2,9,0,2,10,0,9,19,0,9,19,0,2,11,0,2,12,0,9,20,0,9,20,0,2,13,0,2,14,0,0,15,0,0,15,0,5,1,52],[0,0,0,0,0,0,0,0,0,0,0,0],[3,7,3,3,3,3,3,3,3,3,3,3],[3,64,3,3,3,3,3,3,3,3,3,65]],[[[42,"Skin-0",1727875492,["Armature/root","Armature/root/FrontFoot.R","Armature/root/Body","Armature/root/Body/FrontLeg.R","Armature/root/Body/FrontLeg.R/FrontUpLeg.R","Armature/root/Body/FrontLeg.R/FrontUpLeg.R/FrontLowLeg.R","Armature/root/Body/BackLeg.R","Armature/root/Body/BackLeg.R/BackUpLeg.R","Armature/root/Body/BackLeg.R/BackUpLeg.R/BackLowLeg.R","Armature/root/Body/FrontLeg.L","Armature/root/Body/FrontLeg.L/FrontUpLeg.L","Armature/root/Body/FrontLeg.L/FrontUpLeg.L/FrontLowLeg.L","Armature/root/Body/BackLeg.L","Armature/root/Body/BackLeg.L/BackUpLeg.L","Armature/root/Body/BackLeg.L/BackUpLeg.L/BackLowLeg.L","Armature/root/Body/Back","Armature/root/Body/Back/Tail1","Armature/root/Body/Back/Tail1/Tail2","Armature/root/Body/Back/Tail1/Tail2/Tail3","Armature/root/Body/Back/Tail1/Tail2/Tail3/Tail4","Armature/root/Body/Shoulders","Armature/root/Body/Shoulders/Neck","Armature/root/Body/Shoulders/Neck/Head","Armature/root/Body/Hips","Armature/root/Body/Hips/Torso","Armature/root/BackFoot.R","Armature/root/FrontFoot.L","Armature/root/BackFoot.L"],[[[7,1,0,0,0,0,6.123234262925839e-17,-1,0,0,1,6.123234262925839e-17,0,0,0,0,1],[7,1,1.075455965353978e-22,-0.0000017563529581821058,0,-1.075455965353978e-22,-1,-1.2246468525851679e-16,0,-0.0000017563529581821058,1.2246468525851679e-16,-1,0,0.009117711335420609,-0.01927023008465767,0.0010000186739489436,1],[7,1,0,0,0,0,6.123234262925839e-17,-1,0,0,1,6.123234262925839e-17,0,-0.0000537765008630231,-0.023020826280117035,0.00017354160081595182,1],[7,-7.943073146920651e-14,-1,-3.956771479352028e-7,0,1.9470718370939721e-7,3.956771479352028e-7,-1,0,1,-1.5647192200783644e-13,1.9470718370939721e-7,0,-0.03140079602599144,-0.0031930229160934687,-0.018557406961917877,1],[7,0.9992793202400208,7.817317992930839e-8,0.03795882686972618,0,-0.03744172304868698,-0.16449666023254395,0.985666811466217,0,0.006244175601750612,-0.9863777756690979,-0.1643780767917633,0,0.008321077562868595,0.027920423075556755,0.023802941665053368,1],[7,0.9999998807907104,8.070195889331444e-8,1.987690723126434e-7,0,-2.0585146387475106e-7,0.10014060884714127,0.994973361492157,0,6.039142164127043e-8,-0.9949736595153809,0.10014057904481888,0,0.009218607097864151,0.01881570555269718,0.019205018877983093,1],[7,1.1920848663748984e-7,-1.0000001192092896,-0.0000010154482197322068,0,1.9470715528768778e-7,0.0000010154482197322068,-1,0,1.0000001192092896,1.1920828768552383e-7,1.947072689745255e-7,0,-0.031400807201862335,-0.0031930566765367985,0.02195880562067032,1],[7,0.9992508888244629,3.1871863370724896e-8,-0.03869609907269478,0,0.03139324113726616,0.584661602973938,0.8106695413589478,0,0.022624149918556213,-0.8112770915031433,0.584223747253418,0,0.006483175326138735,0.012636274099349976,-0.036451708525419235,1],[7,1,9.931482480851628e-8,1.284574153714857e-7,0,-1.1668206667536651e-7,-0.11062692850828171,0.9938617944717407,0,1.1291607648900026e-7,-0.9938619136810303,-0.11062690615653992,0,0.007888861000537872,0.025572653859853745,-0.02564503811299801,1],[7,-6.477578754415445e-14,1,-3.956770342483651e-7,0,-2.3215589806113712e-7,3.956770342483651e-7,1,0,1,1.566345387811821e-13,2.3215589806113712e-7,0,-0.03140080347657204,-0.002684251172468066,0.018557392060756683,1],[7,0.9945321083068848,4.430908617791829e-8,-0.10443182289600372,0,0.10300923138856888,-0.16449664533138275,0.9809842109680176,0,-0.017178641632199287,-0.9863777160644531,-0.16359718143939972,0,-0.006211212836205959,0.027920419350266457,0.0242511797696352,1],[7,1,7.040221561283033e-8,2.3092101741895021e-7,0,-2.368103366734431e-7,0.10014048963785172,0.994973361492157,0,4.6923773311391415e-8,-0.9949734210968018,0.10014048218727112,0,-0.00870984885841608,0.01881568878889084,0.019205018877983093,1],[7,-9.405196890396872e-13,1,-0.0000010154477649848559,0,-8.922222605178831e-8,0.0000010154477649848559,1,0,1,1.0311201762217004e-12,8.922222605178831e-8,0,-0.03140079602599144,-0.0026842805091291666,-0.021958813071250916,1],[7,0.9998193979263306,-2.6094554073097243e-8,0.01900486648082733,0,-0.01541819702833891,0.5846618413925171,0.8111305236816406,0,-0.011111441068351269,-0.8112771511077881,0.5845562219619751,0,-0.006691282149404287,0.012636265717446804,-0.036307260394096375,1],[7,1,3.1782598775009774e-9,2.6798463181876286e-7,0,-2.6598817726153356e-7,-0.11062703281641006,0.9938620328903198,0,3.280509730529957e-8,-0.9938620924949646,-0.11062702536582947,0,-0.0073800827376544476,0.025572657585144043,-0.025645041838288307,1],[7,1,1.3010425425610684e-22,4.76837158203125e-7,0,1.3881683003091894e-7,-0.9566864967346191,-0.2911199927330017,0,4.56183670394239e-7,0.2911199927330017,-0.9566864967346191,0,0.00026903030811809003,0.012349234893918037,0.04253220558166504,1],[7,1,1.2409302752036666e-10,4.582857964646747e-12,0,-1.2416137562532015e-10,0.9985907673835754,0.053069405257701874,0,2.009153694110255e-12,-0.05306966230273247,0.9985859990119934,0,0.00015737058129161596,-0.024428974837064743,-0.04922361299395561,1],[7,1,-2.3420737571555605e-10,2.3842022756070946e-7,0,-2.3413187477672182e-7,0.18785133957862854,0.9821969270706177,0,-4.501780992427484e-8,-0.9821930527687073,0.18785202503204346,0,0.00015738098591100425,0.039924945682287216,-0.04364730417728424,1],[7,-1,7.035073912309286e-11,3.8943693425608217e-7,0,-3.8728725826331356e-7,-0.10510523617267609,-0.9944610595703125,0,4.0862090600057854e-8,-0.9944562911987305,0.10510572791099548,0,-0.00015735780471004546,0.042466901242733,0.03273717686533928,1],[7,-1,5.799694946517775e-8,3.1960988167156756e-7,0,-3.2482691381119366e-7,-0.18237243592739105,-0.9832294583320618,0,1.263730675660213e-9,-0.983224630355835,0.18237334489822388,0,-0.00015735880879219621,0.03791962191462517,0.029869725927710533,1],[7,-0.9983536601066589,0.03149224445223808,-0.04793712869286537,0,-0.05735006928443909,-0.5359179973602295,0.8423197865486145,0,0.0008361703949049115,0.8436827659606934,0.536841630935669,0,-0.0017681776080280542,-0.044484321027994156,-0.00664231413975358,1],[7,-1.0000001192092896,1.0994877008840831e-8,0.000005181227152206702,0,0.000003803521849476965,-0.6774875521659851,0.7355341911315918,0,0.0000035183045383746503,0.7355343699455261,0.6774874925613403,0,-0.0002691377012524754,-0.055580634623765945,-0.016679488122463226,1],[7,-0.8662223815917969,-0.0015339370584115386,0.4996565282344818,0,-0.27237826585769653,-0.8368988037109375,-0.4747740626335144,0,0.41889023780822754,-0.5473552942276001,0.7245228886604309,0,-0.035693008452653885,0.005083934403955936,-0.06132461130619049,1],[7,-1,2.092813905030591e-13,0.000009687739293440245,0,-3.4448314067958563e-7,-0.9993674159049988,-0.03555864840745926,0,0.000009681612027634401,-0.03555864840745926,0.9993675351142883,0,-0.00026943194097839296,0.016325578093528748,-0.03936338797211647,1],[7,-0.9996330142021179,-0.02709319442510605,-0.00005722550122300163,0,0.02701888047158718,-0.9970430135726929,0.07193925976753235,0,-0.0020061202812939882,0.0719112902879715,0.9974091053009033,0,-0.00019675440853461623,-0.0025880569592118263,-0.039313461631536484,1],[7,1,1.075455965353978e-22,-0.0000017563529581821058,0,-1.075455965353978e-22,-1,-1.2246468525851679e-16,0,-0.0000017563529581821058,1.2246468525851679e-16,-1,0,0.008358626626431942,0.026047201827168465,0.0010000200709328055,1],[7,1,1.6594129641253459e-22,-0.0000027100270472146804,0,-1.6594129641253459e-22,-1,-1.2246468525851679e-16,0,-0.0000027100270472146804,1.2246468525851679e-16,-1,0,-0.00860893726348877,-0.01927023008465767,0.001000058138743043,1],[7,1,1.6594129641253459e-22,-0.0000027100270472146804,0,-1.6594129641253459e-22,-1,-1.2246468525851679e-16,0,-0.0000027100270472146804,1.2246468525851679e-16,-1,0,-0.007849853485822678,0.026047201827168465,0.00100005604326725,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[27,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":9.607843137254903,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4280756007],"emissive",8,[4,4280756007]],{},{}],11,0,0]]],0,0,[0],[8],[2]],[[[32],[29,"Horse",[-3,-4],[[40,-2,[8,"1fzKoYooBSiqbvklfJE2ny"],[4,5,6,7,8,9],10]],[0,"eaxt5Sh2ZWWYI8r8AeP323",-1,0]],[33,"Body",[-5,-6,-7,-8,-9,-10,-11],[0,"621WcCUZ5e2YDx5Tw4WuyQ",1,0],[1,0.0000537765008630231,0.023020822554826736,-0.00017354160081595182]],[34,"root",[-12,2,-13,-14,-15],[0,"19z7gJkZVWqpghf0bFSF2w",1,0],[3,0.7071068407911908,0,0,0.7071067215818992],[1,90.00000965934633,0,0]],[35,"Armature",1,[3],[0,"c6iDqTOcxQvY1iD0ueskYy",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[5,"FrontFoot.R",3,[[4,"FrontFoot.R_end",-16,[0,"33I/MYkzxd34rB2w/7ksWs",1,0],[1,-1.1102229998097382e-18,0.009999999776482582,1.3877787497621727e-19]]],[0,"a44yApoA5fkYj5yjWTF5Tg",1,0],[1,-0.009117710404098034,0.0010000348556786776,0.01927023008465767],[3,0.7071068407909181,-6.209646236899395e-7,-6.209645668465197e-7,0.7071067215816265],[1,90.00000965934633,3.87667620832701e-12,-0.0001006316202376715]],[3,"FrontLeg.R",2,[-17],[0,"89K+dEJOtT/5PCB1wHPZLg",1,0],[1,-0.0032468067947775126,0.008379977196455002,0.01873094029724598],[3,0.0012952884202324106,-0.0012955682826612425,0.7071055647628505,0.7071056243674941],[1,89.99867052826072,-89.99869320512238,89.79006673189204]],[3,"FrontUpLeg.R",6,[-18],[0,"788AFkKphTmpJqpRVuAi4Z",1,0],[1,2.4487718519594637e-9,0.006025583017617464,6.021457221727644e-10],[3,0.706853564541443,-0.7022758682440338,-0.04508993749057004,0.07164873142101912],[1,95.04363367817759,-75.48471135759631,-87.81611699616465]],[5,"FrontLowLeg.R",7,[[4,"FrontLowLeg.R_end",-19,[0,"bcFD0g9TdbvKLyTmuWwINq",1,0],[1,0,0.015877680853009224,2.2204459996194763e-18]]],[0,"0bNmUKZg5Qopme8auFoE21",1,0],[1,8.19563861220729e-10,0.014804559759795666,7.450580430390374e-11],[3,0.1331460446931698,-0.018813656233402656,0.0025279523720033188,0.9909146212356041],[1,15.305631002608129,-2.175391787385122,0.000002412554620199633]],[3,"BackLeg.R",2,[-20],[0,"00b0496+ZXgY6Y3Vnr70oS",1,0],[1,-0.0032468067947775126,0.008379977196455002,-0.021785270422697067],[3,0.0007835572993493648,-0.000784275465464433,0.7071063466516025,0.7071063466516025],[1,89.99997090402447,-90.00002909596121,89.87296088624299]],[3,"BackUpLeg.R",9,[-21],[0,"e6l6Y0ONlWh4eR6RBvY/W0",1,0],[1,2.6392144025777498e-9,0.004695829935371876,2.844441349125759e-9],[3,-0.6711558061437017,0.6744514661419378,-0.20213857166258833,0.2319592669948692],[1,-65.8136082604064,78.42660923213249,-87.56878091632545]],[5,"BackLowLeg.R",10,[[4,"BackLowLeg.R_end",-22,[0,"63NiV51RJUTI2xoVTxxJ7n",1,0],[1,0,0.021711884066462517,-4.440891999238953e-18]]],[0,"cd/QjGGjNVXJyPM3VFDjh8",1,0],[1,-1.303851610012785e-10,0.010874390602111816,1.3783574281944766e-9],[3,-0.357463601726651,0.018072592270244717,0.0069187652060998615,0.9337265582263721],[1,-41.8972320491341,2.2176787497755472,-0.000006772635116469312]],[3,"FrontLeg.L",2,[-23],[0,"b6wuasjBZVcIXwA5Su3vta",1,0],[1,0.002630481729283929,0.008379977196455002,0.01873094029724598],[3,0.7071054153926467,0.7071054749972929,0.0013744056093762014,-0.0013746855882320113],[1,-89.99874639371293,-90.00123091999457,89.77724521028026]],[3,"FrontUpLeg.L",12,[-24],[0,"0fp3+G2gxXoKgUFg47jP5W",1,0],[1,-1.756112921746933e-9,0.006025584880262613,8.378248095297636e-10],[3,-0.02159131891643826,-0.0950879461007112,0.7079610872193227,0.6994878100703624],[1,91.83742545141908,-101.31553480725925,84.00249672666698]],[5,"FrontLowLeg.L",13,[[4,"FrontLowLeg.L_end",-25,[0,"a2+3Ek8+Zdl7BH2rleInj8",1,0],[1,0,0.015877680853009224,0]]],[0,"6cpNdZOdJTQosvE5xZMmcx",1,0],[1,5.21540644005114e-10,0.01480456069111824,-2.2351742678949904e-9],[3,0.13298889845622416,0.0518218384837552,-0.006963174712129553,0.9897373207783426],[1,15.30574958155501,5.994446392534305,0.0000017569448676354595]],[3,"BackLeg.L",2,[-26],[0,"5bI24GBVBRUZ5tPVmUwgPB",1,0],[1,0.002630481729283929,0.008379977196455002,-0.021785270422697067],[3,0.7071064108167839,0.7071065300260734,0.0006625798408461719,-0.000663298006965872],[1,0,180.10749206804024,90]],[3,"BackUpLeg.L",15,[-27],[0,"64jLnWQ0lZjLNVUBxN6b+f",1,0],[1,-1.7321695189309594e-9,0.004695831332355738,-5.743572839556066e-10],[3,0.20885529998403182,0.2254200118205795,0.6690967641935,0.6766644678754589],[1,-47.56156043426251,83.33119945023036,88.52430684541918]],[5,"BackLowLeg.L",16,[[4,"BackLowLeg.L_end",-28,[0,"c6nMiuGa1dtJVTzd1z9Rz2",1,0],[1,1.1102229998097382e-18,0.021711884066462517,0]]],[0,"7fG1gRML5YOohHx1wtXEqA",1,0],[1,1.3876706450588472e-9,0.010874389670789242,-2.9802322831784522e-9],[3,-0.3575146799690923,-0.008874606354457956,-0.003397634490841542,0.9338591708863375],[1,-41.897265414717886,-1.0889531390263516,-0.000012614001200186714]],[3,"Back",2,[-29],[0,"183KhBqOxWL6VKFG499ks0",1,0],[1,-0.0003228271089028567,0.014074056409299374,-0.02402278035879135],[3,0.6010642163827888,-0.0214282017473418,0.028488763208185965,0.7984053045445573],[1,73.98588806223908,-3.92653097532807,1.130617007687284]],[50,"Tail1",18,[-30],[0,"a4b4XAUe9ebp8D+7zFqqje",1,0],[1,0.00011168522905791178,0.0004445839731488377,-0.01111518032848835],[3,0.9926701262969037,2.530156547821115e-8,2.203457983819794e-7,-0.12085536958546783],[1,1,1,1.0000048875808716],[1,-166.1170581079711,-0.000025415092459187126,-1.734761162759429e-7]],[3,"Tail2",19,[-31],[0,"7fa/jbAqNTwYBOeCiplz3B",1,0],[1,-1.490116086078075e-10,0.008375221863389015,-2.9220245667538336e-10],[3,-0.6165577197016348,9.529880210647237e-8,-7.154803710450899e-8,0.7873097092480863],[1,-76.13038874521416,0.0000035427329870885525,-0.000013188076264186874]],[3,"Tail3",20,[-32],[0,"71MKA6+A1Um5o+vjnHaX6K",1,0],[1,1.490116086078075e-10,0.008778818883001804,5.038454986561192e-9],[3,-9.271659996802928e-9,0.9891947031850706,-0.14660777329493307,3.18719632334745e-7],[1,16.860785764413187,179.99996402782176,-0.000006405467907751404]],[5,"Tail4",21,[[4,"Tail4_end",-33,[0,"c1FRtiZxRWurYwrh/97jaX",1,0],[1,0,0.01026824489235878,4.440891999238953e-18]]],[0,"09kjYefSJdrLyJPxDFKIMS",1,0],[1,2.7755574995243454e-19,0.006993298418819904,2.5518238633281953e-9],[3,0.03904001009515864,3.58832782698927e-8,1.491252975259389e-8,0.9992376482157628],[1,4.474792801096338,0.0000040420725472042225,0.000001868076718041104]],[3,"Shoulders",2,[-34],[0,"4eueEnZadYXKw67YmonKrs",1,0],[1,-0.0007365465280599892,0.01807716116309166,0.01851993054151535],[3,0.008421451052746927,0.9597338069228858,0.2794420189265245,-0.02742730518551501],[1,-32.46892103661168,-176.71214203094826,0.04790039382298016]],[3,"Neck",23,[-35],[0,"b86aHRPRNSlYPsNiEiSjnb",1,0],[1,5.122274132629556e-11,0.013137188740074635,2.712476909749739e-10],[3,-0.0886846790567607,-0.022488868112285784,-0.017817650187023866,0.9956464281327185],[1,-10.223395129333626,-2.7493052912714067,-1.804618282098218]],[5,"Head",24,[[4,"Head_end",-36,[0,"46LlRHIk9eKYHVefBjXZ/S",1,0],[1,0,0.01775381900370121,1.776356799695581e-17]]],[0,"9fveWWOtpbjqaKGAnn0NWp",1,0],[1,-2.39742808938459e-11,0.013573313131928444,3.3753928541102596e-9],[3,-0.6245374799606817,-0.19781437896428433,0.16660769604005599,0.7369289539837338],[1,-79.11122360848766,-5.502426603138088,29.51431895269537]],[3,"Hips",2,[-37],[0,"8cSQ9IW4dbsqg2IaURPhQU",1,0],[1,-0.0003228271089028567,0.016898196190595627,-0.014742005616426468],[3,0.000003487624764492713,0.6944211092559098,0.719568845209615,0.0000033658895813566903],[1,-92.03778993215424,-179.99998026259544,0.0005550665619484873]],[5,"Torso",26,[[4,"Torso_end",-38,[0,"2cdEVYoUVQ1IjS6eeN9KTk",1,0],[1,-6.938893748810864e-20,0.015270233154296875,0]]],[0,"c0mTwrj5BSmIROHCA9QTYY",1,0],[1,2.1590436036222904e-11,0.014671733602881432,5.460347729524528e-10],[3,0.05375247793241081,0.0007617085899636836,-0.013526975106839246,0.9984623737831129],[1,6.165413201806021,0.1705337539528226,-1.5431884931505082]],[5,"BackFoot.R",3,[[4,"BackFoot.R_end",-39,[0,"a5kgvCC1Rc4q/JEioQiqJ2",1,0],[1,0,0.006745369639247656,1.3877787497621727e-19]]],[0,"1eWNyDcRtdKLgKaxvBLfhZ",1,0],[1,-0.008358624763786793,0.0010000348556786776,-0.026047201827168465],[3,0.7071068407909181,-6.209646236899395e-7,-6.209645668465197e-7,0.7071067215816265],[1,90.00000965934633,3.87667620832701e-12,-0.0001006316202376715]],[5,"FrontFoot.L",3,[[4,"FrontFoot.L_end",-40,[0,"f2TkfE4ipdbLIPGeRhn8/m",1,0],[1,0,0.009999999776482582,1.3877787497621727e-19]]],[0,"a7j+d1wshfdKkEBLOofHUq",1,0],[1,0.008608940057456493,0.0010000348556786776,0.01927023008465767],[3,0.7071068407905415,-9.581394970415802e-7,-9.581393833547404e-7,0.70710672158125],[1,90.0000096593463,3.876676966638594e-12,-0.00015527314280957484]],[5,"BackFoot.L",3,[[4,"BackFoot.L_end",-41,[0,"2bXyv2FTNd2I4zZTTw1EnD",1,0],[1,0,0.006745369639247656,2.7755574995243454e-19]]],[0,"abthjQJQxXQopI2BUWYcG4",1,0],[1,0.007849856279790401,0.0010000348556786776,-0.026047201827168465],[3,0.7071068407905415,-9.581394970415802e-7,-9.581393833547404e-7,0.70710672158125],[1,90.0000096593463,3.876676966638594e-12,-0.00015527314280957484]],[36,"Horse",1,[[41,-42,[8,"16b0A/pXxQqqTPyffjufCY"],[0,1],[14],1,2,3]],[0,"a13fQhFppV+I/OfrQqaWhH",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]]],0,[0,2,1,0,0,1,0,-1,4,0,-2,31,0,-1,6,0,-2,9,0,-3,12,0,-4,15,0,-5,18,0,-6,23,0,-7,26,0,-1,5,0,-3,28,0,-4,29,0,-5,30,0,1,5,0,-1,7,0,-1,8,0,1,8,0,-1,10,0,-1,11,0,1,11,0,-1,13,0,-1,14,0,1,14,0,-1,16,0,-1,17,0,1,17,0,-1,19,0,-1,20,0,-1,21,0,-1,22,0,1,22,0,-1,24,0,-1,25,0,1,25,0,-1,27,0,1,27,0,1,28,0,1,29,0,1,30,0,0,31,0,5,1,2,1,3,3,1,4,42],[0,0,0,0,0,0,0,0,0,0,0],[-1,-2,6,11,-1,-2,-3,-4,-5,-6,12],[66,67,68,69,15,70,71,72,73,74,15]],[[[27,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":9.607843137254903,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4282207604],"emissive",8,[4,4282207604]],{},{}],11,0,0]]],0,0,[0],[8],[2]],[[[15,".bin",2235295983,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":67328,"length":6048,"count":1512,"stride":4}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[1],"indexView":{"offset":97952,"length":2232,"count":558,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":67328,"count":1052,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":73376,"length":24576,"count":384,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,24,25,26,27]]},"minPosition",8,[1,-0.012848868034780025,-0.05116979777812958,0.0001846075028879568],"maxPosition",8,[1,0.012848868034780025,0.04118158295750618,0.0692378357052803]]],-1],0,0,[],[],[]],[[[15,".bin",383827008,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":145584,"length":12840,"count":3210,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":145584,"count":3033,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8792275190353394,0.03466874361038208,-1.3114221096038818],"maxPosition",8,[1,1.2473176717758179,3.1320736408233643,0.9050227403640747]]],-1],0,0,[],[],[]],[[{"name":"button","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[8,8,8,8],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[75]],[[[17,"wheat_1"],[37,"wheat_1",[-2],[0,"c3WYeDwlRaAZsuyIwXKwHV",-1,0]],[30,"Box004",1,[[21,-3,[8,"92gAjYRZlTzJxzvI2EGxfu"],[0],[14],1]],[0,"f41hermNpTP7qC1dzmP5kJ",1,0]]],0,[0,2,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,6],[0,76]],[[[17,"wheat_3"],[53,"wheat_3",[-2],[0,"8a478nDfZdfZlePO9DkB6i",-1,0],[1,2,2,2]],[30,"Sphere002",1,[[21,-3,[8,"a1BckIPApeTKW//pjKV0ui"],[0],[14],1]],[0,"4cQnPWGChar4kx6fvzqhQU",1,0]]],0,[0,2,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,6],[0,77]],[[[24,"Material_Center",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{"occlusion":0.279,"roughness":0.734,"metallic":0.368,"specularIntensity":0.323},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[14,8],[10,7]],[[[15,".bin",1610563914,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":775880,"length":60012,"count":15003,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":775880,"count":13855,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-7.478819370269775,-0.007862542755901814,-9.398359298706055],"maxPosition",8,[1,17.437158584594727,17.669902801513672,9.69897174835205]]],-1],0,0,[],[],[]],[[[24,"Material #25",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":1}],[[[{"albedoScale":1,"specularFactor":0,"shininessExponent":2,"emissiveScale":0},"mainColor",8,[4,4291480266],"specularColor",8,[4,4294177779],"emissive",8,[4,4278190080]]],11]]],0,0,[0],[8],[2]],[[[32],[37,"Market",[-2],[0,"fcTF/wge1Yj4RHb3yuihdn",-1,0]],[38,"Market",1,[[21,-3,[8,"beJUnU0W5bJpq3/vGbKzub"],[0],[14],1]],[0,"0eMbovdd9awYI3A+Yj2ebm",1,0],[1,0.8405440449714661,2.237990140914917,-37.72267150878906],[3,-5.3389325705350167e-8,0.7071631053332311,-8.428698212540567e-8,0.707050452553035],[1,0.3937009871006012,0.3937009871006012,0.3937009871006012],[1,0.0000025044784062979342,90.00912808225631,-0.000011155500900738616]]],0,[0,2,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,6],[78,79]],[[[17,"Map_BG"],[69,"Map_BG",[-2],[0,"52FZ4kbjJQ05Bh9aFNRMya",-1,0],[1,28.096,0,142.128],[1,3,3,3]],[38,"Map_BG",1,[[21,-3,[8,"24LpwU7LJZ3J1i5cPiv3OU"],[0],[14],1]],[0,"14HLs2dpxU7rXh+QNQS1J0",1,0],[1,28.08900260925293,1.6490017175674438,-49.35600662231445],[3,-0.0035387775737950886,0.04844189790965985,0.019909689133829126,0.9986212814970387],[1,0.3937009871006012,0.3937009871006012,0.3937009871006012],[1,-0.5158822610312086,5.564515049514396,2.259278361356487]]],0,[0,2,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,6],[0,80]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@e9a6d","back":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@40c10","left":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@8fd34","right":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@74afd","top":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@bb97f","bottom":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@7d38f"}]}],[8],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[17,"Plant"],[29,"Plant",[-4],[[105,-2,[8,"5eQjsUjKtEWYuUtsJcky+K"],[1,2]],[43,-3,[8,"6e/LuqlhtPFqToqDS3iUCP"]]],[0,"c46/YsCPVOJYA4mWEpNYRx",-1,0]],[70,"RenderRoot2D",1,[-7,-8,-9],[[43,-5,[8,"edhYBaneJET5R/pAqZtnYt"]],[56,-6,[8,"dbP4fG+EZHLorwkdxA4jAN"]]],[0,"50inU5UR1DcbXaVD3bPzMC",1,0]],[71,"ProgressBar",2,[-14],[[48,-10,[8,"2cguNIOClF75vvSYYcarEK"],[5,70,8]],[95,1,0,true,-11,[8,"2cXw/dcAdKPZOB6w+opTC/"],0],[106,70,1,-13,[8,"576PLgR85GaZqBktGfietb"],-12]],[0,"62PGsx271JIroReawFeVm5",1,0],[1,0,-61.282,0]],[47,"Label",33554432,2,[[48,-15,[8,"0aCMCmguVMRqE0POxRCS5k"],[5,66.17,50.4]],[55,"00:00:00",17,17,-16,[8,"2fPFCMFvVO159+juFhhUiv"]]],[0,"ccURRjhnFNVZgRMTDqHDmf",1,0]],[75,"Bar",33554432,3,[[[81,-17,[8,"63aM0VWlVPb73arZmnjvUJ"],[5,70,8],[0,0,0.5]],-18],4,1],[0,"30IO/W32tL9ax9jjYjk+zv",1,0],[1,-35,0,0]],[47,"StatusNode",33554432,2,[[43,-19,[8,"0elwmh5jdOFYf6p7P3irvq"]]],[0,"0bwDdgCQ9P+6szWe2JOOs1",1,0]],[96,1,0,5,[8,"7e0TekFc5JVJbRzPQu+9Hn"]]],0,[0,2,1,0,0,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,-1,4,0,-2,6,0,-3,3,0,0,3,0,0,3,0,21,7,0,0,3,0,-1,5,0,0,4,0,0,4,0,0,5,0,-2,7,0,0,6,0,5,1,19],[0,0,0,7],[4,-1,-2,4],[81,82,83,84]],[[[15,".bin",2284389915,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":7569296,"length":541200,"count":135300,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":7569296,"count":135166,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-316.681640625,-15.045106887817383,-194.45132446289062],"maxPosition",8,[1,181.64317321777344,29.21985626220703,304.0953369140625]]],-1],0,0,[],[],[]],[[[107,"dcc/imported-specular-glossiness",[{"hash":2838361292,"name":"dcc/imported-specular-glossiness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_NORMAL_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":10,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":11,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":12,"defines":["CC_FORWARD_ADD"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_vertexId","format":11,"location":12,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * (In.tangent.w > 0.0 ? 1.0 : -1.0);\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin mediump float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    if (pcf > 2.9) {\n      return CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      return CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && layer < 0) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          layer = i;\n        }\n      }\n      return layer;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      vec4 csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n      vec4 shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(shadowPos, N, shadowBias);\n    }\n  #endif\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      if (cc_shadowLPNNInfo.w > 0.0) {\n        #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n          shadow = CCCSMFactorBase(position, N, s.shadowBias);\n        #endif\n      } else {\n        #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n          shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n        #endif\n      }\n    }\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec3 lightmap = s.lightmap.rgb;\n    #if CC_USE_HDR\n        lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n    #endif\n    vec3 finalColor = diffuse * lightmap.rgb * shadow;\n  #else\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n      vec3 env = GetEnvReflectionWithMipFiltering(rotationDir, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, rotationDir, s.roughness * (cc_ambientGround.w - 1.0));\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = LinearToSRGB(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = vec4(1.0);\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    texColor.a *= transparencyFactor;\n    baseColor *= texColor;\n  #else\n    baseColor *= diffuseColor;\n  #endif\n  baseColor.rgb *= diffuseFactor;\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n    #if DCC_APP_NAME == DCC_APP_MAYA\n      baseColor.a = 1.0 - baseColor.a;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < alphaThreshold) discard;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  vec4 specularColorAndFactor = getSpecularColorAndFactor();\n  float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n  #if HAS_EXPORTED_GLOSSINESS\n    #if USE_SPECULAR_GLOSSINESS_MAP\n      inGlossiness = 1.0 - texture(specularGlossinessMap, TEXTURE_UV).a;\n    #else\n      inGlossiness = glossiness;\n    #endif\n  #else\n    #if USE_SHININESS_MAP\n      #if USE_SHININESS_MAP_CHANNEL\n        inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).SHININESS_MAP_CHANNEL;\n      #else\n        inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n      #endif\n    #else\n      inGlossiness = convertShininessExponent(shininessExponent);\n    #endif\n    inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n  #endif\n  float inMetallic = 0.0;\n  vec4 albedo = baseColor;\n  #if HAS_EXPORTED_METALLIC\n    inMetallic = metallic;\n    float spec = specularFactor;\n    #if USE_SPECULAR_MAP\n      spec = dot(GRAY_VECTOR, texture(specularMap, TEXTURE_UV).rgb);\n    #endif\n    inSpecularIntensity *= spec * 0.5;\n  #else\n    GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n    inSpecularIntensity *= inMetallic;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalScale) * normalize(v_tangent) +\n      (nmmp.y * normalScale) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    packHighpData(s.position, s.position_fract_part, v_position);\n    #else\n    s.position = v_position;\n    #endif\n  s.albedo = albedo;\n  s.occlusion = 1.0;\n  s.roughness = 1.0 - inGlossiness;\n  s.metallic = inMetallic;\n  s.specularIntensity = inSpecularIntensity * 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW  && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCFragOutput(CCStandardShadingBase(s, v_shadowPos));\n    #if CC_USE_FOG != 4\n      CC_APPLY_FOG(color, s.position.xyz);\n    #endif\n    fragColorX = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * (In.tangent.w > 0.0 ? 1.0 : -1.0);\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_debug_view_mode;\n  uniform mediump vec4 cc_debug_view_composite_pack_1;\n  uniform mediump vec4 cc_debug_view_composite_pack_2;\n  uniform mediump vec4 cc_debug_view_composite_pack_3;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 diffuseColor;\n     uniform vec4 specularColor;\n     uniform vec4 emissive;\n     uniform float emissiveScale;\n     uniform float alphaThreshold;\n     uniform float shininessExponent;\n     uniform float glossiness;\n     uniform float metallic;\n     uniform float normalScale;\n     uniform float transparencyFactor;\n     uniform float diffuseFactor;\n     uniform float specularFactor;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    if (pcf > 2.9) {\n      return CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      return CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && layer < 0) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          layer = i;\n        }\n      }\n      return layer;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      vec4 csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n      vec4 shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(shadowPos, N, shadowBias);\n    }\n  #endif\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      if (cc_shadowLPNNInfo.w > 0.0) {\n        #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n          shadow = CCCSMFactorBase(position, N, s.shadowBias);\n        #endif\n      } else {\n        #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n          shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n        #endif\n      }\n    }\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec3 lightmap = s.lightmap.rgb;\n    #if CC_USE_HDR\n        lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n    #endif\n    vec3 finalColor = diffuse * lightmap.rgb * shadow;\n  #else\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n      vec3 env = GetEnvReflectionWithMipFiltering(rotationDir, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, rotationDir, s.roughness * (cc_ambientGround.w - 1.0));\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = LinearToSRGB(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture2D(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture2D(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = vec4(1.0);\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    texColor.a *= transparencyFactor;\n    baseColor *= texColor;\n  #else\n    baseColor *= diffuseColor;\n  #endif\n  baseColor.rgb *= diffuseFactor;\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n    #if DCC_APP_NAME == DCC_APP_MAYA\n      baseColor.a = 1.0 - baseColor.a;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < alphaThreshold) discard;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  vec4 specularColorAndFactor = getSpecularColorAndFactor();\n  float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n  #if HAS_EXPORTED_GLOSSINESS\n    #if USE_SPECULAR_GLOSSINESS_MAP\n      inGlossiness = 1.0 - texture2D(specularGlossinessMap, TEXTURE_UV).a;\n    #else\n      inGlossiness = glossiness;\n    #endif\n  #else\n    #if USE_SHININESS_MAP\n      #if USE_SHININESS_MAP_CHANNEL\n        inGlossiness = 1.0 - texture2D(shininessExponentMap, TEXTURE_UV).SHININESS_MAP_CHANNEL;\n      #else\n        inGlossiness = 1.0 - discolor(texture2D(shininessExponentMap, TEXTURE_UV).rgb);\n      #endif\n    #else\n      inGlossiness = convertShininessExponent(shininessExponent);\n    #endif\n    inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n  #endif\n  float inMetallic = 0.0;\n  vec4 albedo = baseColor;\n  #if HAS_EXPORTED_METALLIC\n    inMetallic = metallic;\n    float spec = specularFactor;\n    #if USE_SPECULAR_MAP\n      spec = dot(GRAY_VECTOR, texture2D(specularMap, TEXTURE_UV).rgb);\n    #endif\n    inSpecularIntensity *= spec * 0.5;\n  #else\n    GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n    inSpecularIntensity *= inMetallic;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalScale) * normalize(v_tangent) +\n      (nmmp.y * normalScale) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    packHighpData(s.position, s.position_fract_part, v_position);\n    #else\n    s.position = v_position;\n    #endif\n  s.albedo = albedo;\n  s.occlusion = 1.0;\n  s.roughness = 1.0 - inGlossiness;\n  s.metallic = inMetallic;\n  s.specularIntensity = inSpecularIntensity * 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW  && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCFragOutput(CCStandardShadingBase(s, v_shadowPos));\n    #if CC_USE_FOG != 4\n      CC_APPLY_FOG(color, s.position.xyz);\n    #endif\n    gl_FragData[0] = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":142,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":114}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"SHININESS_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"HAS_EXPORTED_GLOSSINESS","type":"boolean"},{"name":"USE_SHININESS_MAP_CHANNEL","type":"boolean"},{"name":"HAS_EXPORTED_METALLIC","type":"boolean"},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"}]},{"hash":2373376484,"name":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TRANSPARENCY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_vertexId","format":11,"location":12,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":13,"defines":[]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout highp vec2 v_clip_depth;\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n    mediump vec4 cc_debug_view_mode;\n    mediump vec4 cc_debug_view_composite_pack_1;\n    mediump vec4 cc_debug_view_composite_pack_2;\n    mediump vec4 cc_debug_view_composite_pack_3;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_surfaceTransform;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin highp vec2 v_clip_depth;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  #if USE_ALPHA_TEST\n    float alpha = diffuseColor.a;\n    #if USE_VERTEX_COLOR\n      alpha *= v_color.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha *= texture(albedoMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_TRANSPARENCY_MAP\n      alpha = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        alpha = 1.0 - alpha;\n      #endif\n    #endif\n    if (alpha < alphaThreshold) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 diffuseColor;\n   uniform float alphaThreshold;\n   uniform float transparencyFactor;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  #if USE_ALPHA_TEST\n    float alpha = diffuseColor.a;\n    #if USE_VERTEX_COLOR\n      alpha *= v_color.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha *= texture2D(albedoMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_TRANSPARENCY_MAP\n      alpha = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        alpha = 1.0 - alpha;\n      #endif\n    #endif\n    if (alpha < alphaThreshold) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":57,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":114}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]]]]
