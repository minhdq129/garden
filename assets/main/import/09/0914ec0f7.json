[1,["1brw/JvvpFnIvdrxpFCgMZ","443PcKwOVCp6Q72r8m6Cck@f9941","267ggqTqpCSI8ARbHe1YuS@17464","267ggqTqpCSI8ARbHe1YuS@e225b","20B+043CNHFog39aR9bkZZ@ffea3","86jWBogPVLcJYlFxFwSXNU@7361f","f2NJNfrGJH0Y83n68bgleL","9f40zQ0zxPbpBjF1e5+cRN","fcNFsZwfFCv7719AmL6tbL@6e2ba","54LnRrT2hNZrdCBnZOSGRO@34c5b","59XsPZfitDPY1ZJNQYfzVj@3fdbc","59XsPZfitDPY1ZJNQYfzVj@d8c69","59XsPZfitDPY1ZJNQYfzVj@1b5e0","f6SJZOjTJB/JrJeh5xTdF7","7akS6Nt39D1alXJLFDdQZe","daHj9vIJRICpf2QqG7H2Cg","f97Ka5neVPsJYYPU9xSBRc@18391","acEvkfGRdG9J/LYRphA9mr","10dGxLaDNMmo1c2HqNUkjB@fd5d9","80ip9rhxpF0Iqdnb54Nwnd@f63ba","c0ybUnzDlAkbRlvoGqJgHH@f9941","afr0r0GaFP052oWVZQszba@3fdbc","03E/diQb9JNovokTsSzy0a@f9941","02ujuA569P1K/OwbKxxHjE@1f97b","02ujuA569P1K/OwbKxxHjE@3fdbc","03E/diQb9JNovokTsSzy0a@6c48a","5el5iUlHpIQIxYbILXzcwS@00773","5el5iUlHpIQIxYbILXzcwS@17464","5el5iUlHpIQIxYbILXzcwS@935df","5el5iUlHpIQIxYbILXzcwS@3fdbc","5el5iUlHpIQIxYbILXzcwS@1f97b","5el5iUlHpIQIxYbILXzcwS@9aee8","10dGxLaDNMmo1c2HqNUkjB@17464","10dGxLaDNMmo1c2HqNUkjB@2c26d","20B+043CNHFog39aR9bkZZ@bcb7d","20B+043CNHFog39aR9bkZZ@41ac8","30fBCdpKpA+opExpfv1f0z@6c48a","3bML1E5nJFX4Skwc0sj2A9@6e70c","09olZwhcVNRpTcjoYeHSX9","d4pMOAkUFMrrnC++184cZ+","f78/W+G9xAqJgy++3PdSzT","5dJ3FrawFIwrxUl/hejTRy","afr0r0GaFP052oWVZQszba@dba17","8fiQx5fQBDk4nF1Pf8IFgA@a1f87","ecNXr7qHhDGJNb7Z3Zr1Z1","a1+mjz+A1IuJG7WRPkedBE","cf4uZlIzNMl7k6WPLbL24W@8168e","8bVfVWLm5NyK6c7Atoyvwu","9cKjvOHoNETL5SywO1FSF5","69/wr8E6FKkpTwaZio0CaJ","e7uZSgqypAxa+v7bPep4RT","d0MqyYBeFAkIi762QNy1/B@b47c0","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","443PcKwOVCp6Q72r8m6Cck@6c48a","54LnRrT2hNZrdCBnZOSGRO@9f269","54LnRrT2hNZrdCBnZOSGRO@00773","54LnRrT2hNZrdCBnZOSGRO@90d37","60Rad53L5L6IxGY0rIvYXR@6e70c","60Rad53L5L6IxGY0rIvYXR@c28f0","60Rad53L5L6IxGY0rIvYXR@c5460","fet4FEEGtMV4sQx53a7Prs@3fdbc","fet4FEEGtMV4sQx53a7Prs@d8c69","fet4FEEGtMV4sQx53a7Prs@a9044","6acQ7NLaBBmr/CP28xC4ZS@00773","6acQ7NLaBBmr/CP28xC4ZS@4485f","6acQ7NLaBBmr/CP28xC4ZS@287a1","80ip9rhxpF0Iqdnb54Nwnd@17464","80ip9rhxpF0Iqdnb54Nwnd@2af8f","86jWBogPVLcJYlFxFwSXNU@9f269","86jWBogPVLcJYlFxFwSXNU@00aa9","3bML1E5nJFX4Skwc0sj2A9@c28f0","3bML1E5nJFX4Skwc0sj2A9@6b818","8fiQx5fQBDk4nF1Pf8IFgA@9f269","8fiQx5fQBDk4nF1Pf8IFgA@00773","8fiQx5fQBDk4nF1Pf8IFgA@f8fd1","b85SLUTkVLeYvTO+zYDYAW@c28f0","b85SLUTkVLeYvTO+zYDYAW@d82c5","80g4hRr8dI/ZlgnLjiuomw","eeNOtSQu5I5In32N0miD2H@3fdbc","eeNOtSQu5I5In32N0miD2H@d8c69","eeNOtSQu5I5In32N0miD2H@c4aec","5f9KO1YdRGPKm1FNGNsTKw@17464","5f9KO1YdRGPKm1FNGNsTKw@241a2","afr0r0GaFP052oWVZQszba@7d639","afr0r0GaFP052oWVZQszba@17464","afr0r0GaFP052oWVZQszba@935df","afr0r0GaFP052oWVZQszba@1f97b","afr0r0GaFP052oWVZQszba@2fdb0","b85SLUTkVLeYvTO+zYDYAW@6e70c","c0ybUnzDlAkbRlvoGqJgHH@6c48a","cf4uZlIzNMl7k6WPLbL24W@17464","cf4uZlIzNMl7k6WPLbL24W@9e51f","cf4uZlIzNMl7k6WPLbL24W@3fdbc","cf4uZlIzNMl7k6WPLbL24W@1f97b","cf4uZlIzNMl7k6WPLbL24W@dfbe1","cf4uZlIzNMl7k6WPLbL24W@00773","cf4uZlIzNMl7k6WPLbL24W@84583","66TaRkLG9I4rBSUA4YoGCk@3fdbc","66TaRkLG9I4rBSUA4YoGCk@d8c69","66TaRkLG9I4rBSUA4YoGCk@780b2","30fBCdpKpA+opExpfv1f0z@f9941","33nZhkcL5HQ4ascUKgzmG/@3fdbc","33nZhkcL5HQ4ascUKgzmG/@dfbe1","33nZhkcL5HQ4ascUKgzmG/@d077b","8c7GGyQxRH7prbuPzaLDxp@9f269","8c7GGyQxRH7prbuPzaLDxp@3fdbc","8c7GGyQxRH7prbuPzaLDxp@941cc","02ujuA569P1K/OwbKxxHjE@4984d","02ujuA569P1K/OwbKxxHjE@00773","02ujuA569P1K/OwbKxxHjE@935df","02ujuA569P1K/OwbKxxHjE@17464","02ujuA569P1K/OwbKxxHjE@5c073","f97Ka5neVPsJYYPU9xSBRc@9f269","f97Ka5neVPsJYYPU9xSBRc@3fdbc","f97Ka5neVPsJYYPU9xSBRc@d8c69","f97Ka5neVPsJYYPU9xSBRc@17464","f97Ka5neVPsJYYPU9xSBRc@a8cf7","fcNFsZwfFCv7719AmL6tbL@9f269","fcNFsZwfFCv7719AmL6tbL@00773","fcNFsZwfFCv7719AmL6tbL@86bd5"],["node","root","asset","_effectAsset","_mesh","data","targetInfo","_spriteFrame","_normalSprite","_parent","_textureSource","mainTexture","_cameraComponent","scene","plantPrefab","_envmapHDR","_envmapLDR"],[["cc.Node",["_name","_layer","_id","_objFlags","__editorExtras__","_active","_parent","_components","_children","_prefab","_lpos","_lscale","_lrot","_euler"],-3,1,9,2,4,5,5,5,5],"cc.ImageAsset","cc.SpriteFrame",["cc.UITransform",["node","_contentSize","__prefab"],3,1,5,4],["cc.PrefabInfo",["fileId","root","asset","nestedPrefabInstanceRoots"],2,1,1,2],["cc.PrefabInstance",["fileId","propertyOverrides","mountedChildren","prefabRootNode"],2,9,9,1],"cc.TextureCube",["cc.Prefab",["_name"],2],["cc.MeshRenderer",["node","_materials","lightmapSettings","_mesh","__prefab"],3,1,3,4,6,4],["cc.Widget",["_alignFlags","_left","_right","node"],0,1],["cc.Sprite",["_type","_sizeMode","node","_spriteFrame","__prefab"],1,1,6,4],["cc.ClickEvent",["_componentId","handler","customEventData","target"],0,1],["cc.Label",["_string","_actualFontSize","_fontSize","node","__prefab"],0,1,4],["cc.Camera",["_projection","_orthoHeight","_clearFlags","_visibility","_priority","_far","node","_color"],-3,1,5],["cc.Material",["_states","_defines","_props"],1,12],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Node",["_name","_parent","_components","_lpos"],2,1,2,5],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.CompPrefabInfo",["fileId"],2],["cc.ModelLightmapSettings",[],3],["cc.SceneAsset",["_name"],2],["88b43Dzh+dBnLrzmp5945Wu",["node"],3,1],["9ddefGqg0dAVpQkQmCMz4vd",["node"],3,1],["cc.MountedChildrenInfo",["targetInfo","nodes"],3,4,2],["cc.TargetInfo",["localID"],2],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,12,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5],["cc.ShadowsInfo",["_distance","_shadowColor"],2,5],["cc.SkyboxInfo",["_enabled","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",["_fogStart","_fogColor"],2,5],["cc.OctreeInfo",["_enabled"],2],["cc.Canvas",["node","_cameraComponent"],3,1,1],["cc.Button",["_transition","_zoomScale","node","clickEvents","_normalSprite"],1,1,9,6],["cc.DirectionalLight",["node","_color","_staticSettings"],3,1,5,4],["cc.StaticLightSettings",[],3],["734feVQSzdG76tFES30ltsr",["node","renderPlantPrefabs","plantPrefab"],3,1,3,6],["7865329OKBPiq+nR+pIYnyH",["node","__prefab","statusSpriteFrames"],3,1,4,3],["cc.RenderRoot2D",["node","__prefab"],3,1,4],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[24,0,2],[26,0,1,2,2],[27,0,1,2,2],[17,0,1,2,3,2],[0,3,4,6,9,3],[25,0,1,2,3],[4,0,1,2,2],[14,0,1,2,3],[5,0,1,2],[19,1],[18,0,2],[15,0,1,2,3],[8,0,4,1,2,3,1],[3,0,1,1],[28,0,1,2,3],[0,0,6,7,9,2],[7,0,2],[0,0,8,9,2],[0,0,1,6,7,3],[10,0,1,2,3,3],[8,0,1,2,3,1],[7,1],[5,0,3,1,2],[37,0,1,2,3,4,3],[12,0,1,2,3,4],[0,0,1,6,8,7,10,3],[0,0,6,7,10,12,11,13,2],[0,0,8,9,10,11,2],[11,0,1,3,3],[11,0,1,2,3,4],[0,0,6,7,10,11,2],[0,0,6,7,9,10,2],[0,0,6,7,9,11,2],[0,0,8,9,10,12,11,13,2],[0,0,6,8,7,9,2],[3,0,2,1],[0,0,8,2],[0,0,5,1,8,7,10,4],[0,0,2,6,8,3],[0,0,1,6,8,7,3],[0,0,8,7,9,2],[3,0,1],[3,0,2,1,1],[9,0,3,2],[5,0,2,1,2],[23,0,1,1],[0,0,6,7,9,10,11,2],[0,0,8,10,11,2],[0,3,4,9,3],[0,0,2,6,3],[0,0,8,10,2],[0,0,1,2,6,8,7,10,4],[0,0,2,6,7,12,13,3],[0,0,2,6,7,10,12,13,3],[0,0,2,6,7,3],[0,0,6,8,9,10,2],[0,0,1,6,7,9,3],[0,0,1,6,7,9,10,11,3],[0,0,8,9,10,2],[16,0,1,2,3,2],[4,0,3,2],[4,0,1,2,3,2],[20,0,2],[21,0,1],[9,0,1,2,3,4],[22,0,1],[29,0,1,2,3,2],[30,0,1,2,3,4,1],[31,0,1,2,3,2],[32,0,1,2],[33,0,1,2,2],[34,0,1,2],[35,0,2],[36,0,1,1],[10,2,4,3,1],[12,0,1,2,3,4,4],[38,0,1,2,1],[39,1],[13,0,1,2,3,6,5],[13,0,4,1,5,2,3,6,7,7],[40,0,1,2,1],[41,0,1,2,1],[42,0,1,1],[43,0,1,2,4]],[[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.7029160857200623,0.4253237545490265,0.20689357817173004]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.1923278123140335,0.22819341719150543,0.24619518220424652]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.5778115391731262,0.23347531259059906,0.11534765362739563]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",1679431067,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8448,"length":552,"count":276,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":34344,"length":1632,"count":816,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":8448,"count":176,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":9000,"length":25344,"count":528,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.6885064244270325,-0.688506543636322,-0.09218445420265198],"maxPosition",8,[1,0.6885063052177429,0.6885061860084534,0.07097837328910828]]],-1],0,0,[],[],[]],[[[11,".bin",941617625,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2688,"length":192,"count":96,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":18912,"length":2448,"count":1224,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":97056,"length":7572,"count":3786,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":106548,"length":180,"count":90,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":113592,"length":1044,"count":522,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":2688,"count":56,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2880,"length":16032,"count":334,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":21360,"length":75696,"count":1577,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":104628,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":106728,"length":6864,"count":143,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8436155319213867,-0.025585658848285675,-0.8081799745559692],"maxPosition",8,[1,0.8436161279678345,1.6066254377365112,0.8601409196853638]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.799102783203125,0.799102783203125,0.799102783203125]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[{"name":"water_icon","rect":{"x":5,"y":5,"width":119,"height":119},"offset":{"x":0.5,"y":-0.5},"originalSize":{"width":128,"height":128},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-59.5,-59.5,0,59.5,-59.5,0,-59.5,59.5,0,59.5,59.5,0],"indexes":[0,1,2,2,1,3],"uv":[5,123,124,123,5,4,124,4],"nuv":[0.0390625,0.03125,0.96875,0.03125,0.0390625,0.9609375,0.96875,0.9609375],"minPos":{"x":-59.5,"y":-59.5,"z":0},"maxPos":{"x":59.5,"y":59.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[25]],[[[16,"house.gltf"],[27,"house.gltf",[-2],[6,"00knp1gOxWX7tvjA9HJdYE",-1,0],[1,10.473,0,-13.573],[1,10,10,10]],[15,"house",1,[[12,-3,[10,"03JNRfV3pdO4WQAQx3ykTH"],[0,1,2,3,4],[9],5]],[6,"c7M3TvagJRzLnoObDlAJ6o",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0,0,0,0],[-1,-2,-3,-4,-5,4],[26,27,28,29,30,31]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.1923278123140335,0.22819341719150543,0.24619518220424652]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",3229525040,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":21888,"length":3312,"count":1656,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":21888,"count":456,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.26563864946365356,-0.012810967862606049,-0.1890316605567932],"maxPosition",8,[1,0.38001301884651184,0.19927656650543213,0.3403770923614502]]],-1],0,0,[],[],[]],[[[21],[17,"detail_rocks_small",[-2],[6,"a0vP15IIpfAKdgSklTl1lQ",-1,0]],[15,"detail_rocks_small",1,[[12,-3,[10,"93X/APyztUmajSR2ZqU1M4"],[0],[9],1]],[6,"04A4yyWStUqaSMfAbuy45y",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,4],[32,33]],[[[11,".bin",321897862,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2304,"length":252,"count":126,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":2304,"count":48,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.18022269010543823,-0.01484794169664383,-0.15672263503074646],"maxPosition",8,[1,0.18022271990776062,0.01719527691602707,0.15672263503074646]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.5778115391731262,0.23347531259059906,0.11534765362739563]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[21],[17,"farm_plot_slot",[-2],[6,"047WPd4YhflLipehZ6gK4y",-1,0]],[46,"farm_plot_slot",1,[[12,-3,[10,"b8jH+yTS1ZlK/kjb3wvwLp"],[0],[9],1]],[6,"4bxf/9yPpVMZGAn0aI9L/H",1,0],[1,-0.4311656355857849,0.03844444081187248,-0.37951305508613586],[1,1,1,1.0905308723449707]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,4],[34,35]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.1923278123140335,0.22819341719150543,0.24619518220424652]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",2084795096,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":46080,"length":5916,"count":2958,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":46080,"count":960,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8331913948059082,-4.656612873077393e-10,-0.9567052721977234],"maxPosition",8,[1,0.9545031189918518,1.2167316675186157,0.95038902759552]]],-1],0,0,[],[],[]],[[{"name":"bug_icon","rect":{"x":5,"y":5,"width":119,"height":119},"offset":{"x":0.5,"y":-0.5},"originalSize":{"width":128,"height":128},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-59.5,-59.5,0,59.5,-59.5,0,-59.5,59.5,0,59.5,59.5,0],"indexes":[0,1,2,2,1,3],"uv":[5,123,124,123,5,4,124,4],"nuv":[0.0390625,0.03125,0.96875,0.03125,0.0390625,0.9609375,0.96875,0.9609375],"minPos":{"x":-59.5,"y":-59.5,"z":0},"maxPos":{"x":59.5,"y":59.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[36]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",211599302,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1536,"length":120,"count":60,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":3000,"length":108,"count":54,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1536,"count":32,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1656,"length":1344,"count":28,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1,0,-1],"maxPosition",8,[1,1,0.9000000357627869,1]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{"cullMode":0},"depthStencilState":{"depthWrite":false},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.13025973737239838,"metallic":0},"albedoScale",8,[1,0.06462205201387405,0.6740851402282715,0.7510285377502441]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",183825846,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":10416,"length":912,"count":228,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":10416,"count":186,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.014293084852397442,-0.004139110445976257,-0.014089968986809254],"maxPosition",8,[1,0.012645578011870384,0.019803397357463837,0.01107072364538908]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":1,"USE_ALBEDO_MAP":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":2,"specularFactor":0},"mainColor",8,[4,4291480266],"specularColor",8,[4,4294177779],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[11,3],[37,13]],[[[62,"Garden"],[47,"Road",[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19],[1,0,0,-2.323],[1,5,5,5]],[36,"Map_decor",[-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37]],[37,"PopupSelectSeed",false,33554432,[-41,-42,-43,-44,-45,-46,-47],[[41,-38],[63,-39],[43,20,-40]],[1,0,-270,0]],[37,"PopupTool",false,33554432,[-51,-52,-53,-54,-55],[[41,-48],[65,-49],[43,20,-50]],[1,0,-270,0]],[48,0,{},[3,"83SeZfoXpYxqDSeafSTC8H",-67,[44,"344KN+S4dO5YG1MW/G1Cxe",[[45,[0,["83SeZfoXpYxqDSeafSTC8H"]],[-59,-60,-61,-62,-63,-64,-65,-66]]],[[5,"mountain.gltf",["_name"],[0,["83SeZfoXpYxqDSeafSTC8H"]]],[1,["_lpos"],[0,["83SeZfoXpYxqDSeafSTC8H"]],[1,-42.914,0,-63.589]],[1,["_lrot"],[0,["83SeZfoXpYxqDSeafSTC8H"]],[3,0,0,0,1]],[1,["_euler"],[0,["83SeZfoXpYxqDSeafSTC8H"]],[1,0,0,0]],[1,["_lscale"],[0,["83SeZfoXpYxqDSeafSTC8H"]],[1,10,10,10]],[2,["_lpos"],-56,[1,1.372,0,1.814]],[2,["_lrot"],-57,[3,0,0.27713857667062786,0,0.9608299585883958]],[2,["_euler"],-58,[1,0,32.179,0]]]],8]],[66,"Garden",[[-122,-123,-124,-125,[49,"PlantGroup","31Fo8XuCtBSJqATup1PpHY",-126],-127,-128],1,1,1,1,4,1,1],[60,"007536a2-32ee-411e-abc4-efce4a191054",[-68,-69,-70,-71,-72,-73,-74,-75,5,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100,-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121]],[67,[68,0.5208,[2,0.2,0.5,0.8,0.520833125],[2,0.36244,0.486029,0.632565,0.5208],[2,0.437391,0.436011,0.436589,0]],[69,30,[4,4278190080]],[70,true,106,107],[71,100,[4,4285098345]],[72,true]]],[50,"GrassTiled",[-129,-130,-131,-132,-133,-134,-135],[1,0,-0.626,0]],[38,"LandGroup","db3lCbtrtPsaLlLDrYtRaH",6,[-136,-137,-138,-139,-140,-141]],[51,"UI_Canvas",33554432,"81+w69Bx5IVLhSvPTQ9RM7",6,[-146,3,4],[[13,-142,[5,960,640]],[73,-144,-143],[64,45,-5.684341886080802e-14,-5.684341886080802e-14,-145]],[1,479.99999999999994,320,0]],[36,"Background",[-147,5,-148,-149,-150]],[4,0,{},10,[3,"24Ys2U9jpV+qVYrD2vvkNf",-154,[44,"93fA/QvYJKsqHxBJDnaAdO",[[45,[0,["24Ys2U9jpV+qVYrD2vvkNf"]],[-151,-152,-153]]],[[5,"forest.gltf",["_name"],[0,["24Ys2U9jpV+qVYrD2vvkNf"]]],[1,["_lpos"],[0,["24Ys2U9jpV+qVYrD2vvkNf"]],[1,60.058,0,-51.472]],[1,["_lrot"],[0,["24Ys2U9jpV+qVYrD2vvkNf"]],[3,0,0,0,1]],[1,["_euler"],[0,["24Ys2U9jpV+qVYrD2vvkNf"]],[1,0,0,0]],[1,["_lscale"],[0,["24Ys2U9jpV+qVYrD2vvkNf"]],[1,10,10,10]],[1,["_lpos"],[0,["4eFZUQ6GZRHbB4gO3OmK9S"]],[1,-0.468,0,-0.096]]]],26]],[38,"MapKayKit","e4cqRs7oxHSKa17k4VKq+Q",6,[7,10,1,2]],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]],[0,["a6s/76YylUDath8HJKWyRJ"]],[25,"ButtonClose",33554432,3,[-158],[[13,-155,[5,40,40]],[19,1,0,-156,81],[23,3,1.1,-157,[[28,"88b43Dzh+dBnLrzmp5945Wu","hide",3]],82]],[1,268.747,55,0]],[25,"ButtonSeed_1",33554432,3,[-162],[[13,-159,[5,80,80]],[19,1,0,-160,83],[23,3,1.1,-161,[[29,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_00",3]],84]],[1,-200,0,0]],[25,"ButtonSeed_2",33554432,3,[-166],[[13,-163,[5,80,80]],[19,1,0,-164,85],[23,3,1.1,-165,[[29,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_01",3]],86]],[1,-100,0,0]],[39,"ButtonSeed_3",33554432,3,[-170],[[13,-167,[5,80,80]],[19,1,0,-168,87],[23,3,1.1,-169,[[29,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_02",3]],88]]],[25,"ButtonSeed_4",33554432,3,[-174],[[13,-171,[5,80,80]],[19,1,0,-172,89],[23,3,1.1,-173,[[29,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_03",3]],90]],[1,100,0,0]],[25,"ButtonSeed_5",33554432,3,[-178],[[13,-175,[5,80,80]],[19,1,0,-176,91],[23,3,1.1,-177,[[29,"88b43Dzh+dBnLrzmp5945Wu","plant","plant_04",3]],92]],[1,200,0,0]],[25,"ButtonClose",33554432,4,[-182],[[13,-179,[5,40,40]],[19,1,0,-180,94],[23,3,1.1,-181,[[28,"9ddefGqg0dAVpQkQmCMz4vd","hide",4]],95]],[1,164.64,55,0]],[25,"ButtonWatter",33554432,4,[-186],[[13,-183,[5,80,80]],[19,1,0,-184,96],[23,3,1.1,-185,[[28,"9ddefGqg0dAVpQkQmCMz4vd","water",4]],97]],[1,-100,0,0]],[39,"ButtonFertilize",33554432,4,[-190],[[13,-187,[5,80,80]],[19,1,0,-188,98],[23,3,1.1,-189,[[28,"9ddefGqg0dAVpQkQmCMz4vd","fertilize",4]],99]]],[25,"ButtonMove",33554432,4,[-194],[[13,-191,[5,80,80]],[19,1,0,-192,100],[23,3,1.1,-193,[[28,"9ddefGqg0dAVpQkQmCMz4vd","move",4]],101]],[1,100,0,0]],[0,["00knp1gOxWX7tvjA9HJdYE"]],[0,["dbiC/T3S5cFKURapLrUyWC"]],[0,["3bOkID8IdRIpPtzTsDa0zJ"]],[0,["3bOkID8IdRIpPtzTsDa0zJ"]],[0,["44gpMHLDdZBJSLZ/87jJX2"]],[0,["026DiC+npYBqhs90Rl7PXo"]],[0,["a4K9bi/XBTr4e3gZlzYVtr"]],[0,["44gpMHLDdZBJSLZ/87jJX2"]],[0,["026DiC+npYBqhs90Rl7PXo"]],[0,["44gpMHLDdZBJSLZ/87jJX2"]],[0,["026DiC+npYBqhs90Rl7PXo"]],[0,["c46/YsCPVOJYA4mWEpNYRx"]],[0,["c46/YsCPVOJYA4mWEpNYRx"]],[0,["c46/YsCPVOJYA4mWEpNYRx"]],[0,["c46/YsCPVOJYA4mWEpNYRx"]],[0,["c46/YsCPVOJYA4mWEpNYRx"]],[0,["c46/YsCPVOJYA4mWEpNYRx"]],[4,0,{},7,[3,"8duwTerv1d7YHyRlQmUBl3",-195,[8,"84yNeJ7qFJgKlBiiMd6EDW",[[5,"GrassTile",["_name"],[0,["8duwTerv1d7YHyRlQmUBl3"]]],[1,["_lpos"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,-10.922,-1.815,-15.008]],[1,["_lrot"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[3,0,0,0,1]],[1,["_euler"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,0,0,0]],[1,["_lscale"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,1,3,1]],[1,["_lpos"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,0.158,-1.437,0]],[1,["_lscale"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,25.466,1,51.048]]]],0]],[4,0,{},7,[3,"8duwTerv1d7YHyRlQmUBl3",-196,[8,"a7C5SU1qJIDokMF2IaAD/a",[[5,"GrassTile-001",["_name"],[0,["8duwTerv1d7YHyRlQmUBl3"]]],[1,["_lpos"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,58.421,-1.815,-15.008]],[1,["_lrot"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[3,0,0,0,1]],[1,["_euler"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,0,0,0]],[1,["_lscale"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,1,3,1]],[1,["_lpos"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,0,-1.437,0]],[1,["_lscale"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,40,1,51.048]]]],1]],[4,0,{},7,[3,"8duwTerv1d7YHyRlQmUBl3",-197,[8,"86tQUMDQNChKfbm6oOHe0F",[[5,"GrassTile-002",["_name"],[0,["8duwTerv1d7YHyRlQmUBl3"]]],[1,["_lpos"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,58.421,-1.815,86.221]],[1,["_lrot"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[3,0,0,0,1]],[1,["_euler"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,0,0,0]],[1,["_lscale"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,1,3,1]],[1,["_lpos"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,0,-1.437,0]],[1,["_lscale"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,40,1,40]]]],2]],[4,0,{},7,[3,"8duwTerv1d7YHyRlQmUBl3",-198,[8,"727sJFBV9BJKABdDJ3JcFF",[[5,"GrassTile-003",["_name"],[0,["8duwTerv1d7YHyRlQmUBl3"]]],[1,["_lpos"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,-10.922,-1.815,86.221]],[1,["_lrot"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[3,0,0,0,1]],[1,["_euler"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,0,0,0]],[1,["_lscale"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,1,3,1]],[1,["_lpos"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,0.158,-1.437,0]],[1,["_lscale"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,25.466,1,40]]]],3]],[4,0,{},7,[3,"8duwTerv1d7YHyRlQmUBl3",-202,[8,"00y3LIM1dLyp/Jf0p9TC1Z",[[5,"GrassTile-004",["_name"],[0,["8duwTerv1d7YHyRlQmUBl3"]]],[1,["_lpos"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,103.452,2.503,-18.286]],[1,["_lrot"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[3,0,0,0,1]],[1,["_euler"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,0,0,0]],[1,["_lscale"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,1,3,1]],[2,["_lpos"],-199,[1,0,-1.437,0]],[1,["_lscale"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,18.952,2.335,30.441]],[2,["_lrot"],-200,[3,0,0.39814076399745874,0,0.9173243330706539]],[2,["_euler"],-201,[1,0,46.924,0]]]],4]],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[4,0,{},7,[3,"8duwTerv1d7YHyRlQmUBl3",-203,[8,"40sKZ8sHpFSb0niy/5/b0E",[[5,"GrassTile-005",["_name"],[0,["8duwTerv1d7YHyRlQmUBl3"]]],[1,["_lpos"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,116.765,1.079,8.407]],[1,["_lrot"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[3,0,0,0,1]],[1,["_euler"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,0,0,0]],[1,["_lscale"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,0.957,4.247,0.921]],[1,["_lpos"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,-0.181,-3.528,-0.01]],[1,["_lscale"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,18.952,1.2,30.441]]]],5]],[4,0,{},7,[3,"8duwTerv1d7YHyRlQmUBl3",-207,[8,"b75zWpn+9KS4e6BGg7IHph",[[5,"GrassTile-006",["_name"],[0,["8duwTerv1d7YHyRlQmUBl3"]]],[1,["_lpos"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,77.234,1.079,-35.18]],[1,["_lrot"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[3,0,0,0,1]],[1,["_euler"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,0,0,0]],[1,["_lscale"],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[1,0.957,3,0.921]],[2,["_lpos"],-204,[1,-0.352,-1.437,-0.169]],[1,["_lscale"],[0,["8duwTerv1d7YHyRlQmUBl3"]],[1,11.501,1.658,18.474]],[2,["_lrot"],-205,[3,0,-0.34211854583129003,0,0.9396567993678775]],[2,["_euler"],-206,[1,0,-40.012,0]]]],6]],[0,["bdf/FJ+45d0KMa8iAOjOP+"]],[4,0,{},10,[3,"00knp1gOxWX7tvjA9HJdYE",-208,[8,"20rCwwwodPjJrN5p6YGePN",[[14,"house.gltf",["_name"],25],[2,["_lpos"],25,[1,17.974,0.773,-24.92]],[2,["_lrot"],25,[3,0,0,0,1]],[2,["_euler"],25,[1,0,0,0]],[1,["_lscale"],[0,["00knp1gOxWX7tvjA9HJdYE"]],[1,10,10,10]],[1,["_lpos"],[0,["c7M3TvagJRzLnoObDlAJ6o"]],[1,0,0,0.396]]]],7]],[0,["bbj1vKpHBZEpe9sKTpmR43"]],[4,0,{},10,[3,"dbiC/T3S5cFKURapLrUyWC",-212,[8,"2cxn8gXwFEWJhgYhaqsNRD",[[14,"mill.gltf",["_name"],26],[2,["_lpos"],26,[1,60.009,0,14.367]],[2,["_lrot"],26,[3,0,-0.6726703530941419,0,0.7399422923905636]],[2,["_euler"],26,[1,0,-84.547,0]],[1,["_lscale"],[0,["dbiC/T3S5cFKURapLrUyWC"]],[1,10.000000000000002,10,10.000000000000002]],[14,false,["lightmapSettings","_castShadow"],-209],[14,0,["_shadowCastingMode"],-210],[5,1,["_shadowCastingMode"],[0,["544/HxV/lSSZcFpErALKzn"]]],[14,0,["_shadowBias"],-211]]],25]],[0,["1dLgTY6rhVaq1pi1bPq5mL"]],[4,0,null,10,[3,"28/ZOZhUBWpIZ5IHsZ/JcR",-213,[8,"e7OM+3Q/xBkq59JW/FZ/eX",[[5,"watermill.gltf",["_name"],[0,["28/ZOZhUBWpIZ5IHsZ/JcR"]]],[1,["_lpos"],[0,["28/ZOZhUBWpIZ5IHsZ/JcR"]],[1,-20.549,0,36.172]],[1,["_lrot"],[0,["28/ZOZhUBWpIZ5IHsZ/JcR"]],[3,0,0.7071067811865475,0,0.7071067811865476]],[1,["_euler"],[0,["28/ZOZhUBWpIZ5IHsZ/JcR"]],[1,0,90,0]],[1,["_lscale"],[0,["28/ZOZhUBWpIZ5IHsZ/JcR"]],[1,10,10,10]]]],36]],[4,0,null,1,[3,"c1wgYlmNFUkrQDgA4ryQc6",-214,[8,"c5gFRUUv1Gy7FqHIkKmsuF",[[5,"square_forest_roadB.gltf",["_name"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]]],[1,["_lpos"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,1.561,-1,-0.046]],[1,["_lrot"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,0,-89.691,0]]]],37]],[4,0,null,1,[3,"4c3CK6N89Wmpkg1Y4EDSHY",-215,[8,"04rIEBGVVLTqsois6BdvNI",[[5,"square_forest_roadE.gltf",["_name"],[0,["4c3CK6N89Wmpkg1Y4EDSHY"]]],[1,["_lpos"],[0,["4c3CK6N89Wmpkg1Y4EDSHY"]],[1,3.561,-1,-0.056]],[1,["_lrot"],[0,["4c3CK6N89Wmpkg1Y4EDSHY"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["4c3CK6N89Wmpkg1Y4EDSHY"]],[1,0,-89.691,0]]]],38]],[4,0,null,1,[3,"09RRAHhAtZH76lcK7ojAXt",-216,[8,"44TlP9+nJNq5nRTRyL3BOp",[[5,"square_forest_roadA.gltf",["_name"],[0,["09RRAHhAtZH76lcK7ojAXt"]]],[1,["_lpos"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,3.55,-1,-2.04]],[1,["_lrot"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[3,0,0.002696530426450898,0,0.9999963643552207]],[1,["_euler"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,0,0.309,0]]]],39]],[4,0,null,1,[3,"09RRAHhAtZH76lcK7ojAXt",-217,[8,"93Ps6oG21NAa5r8uq75BP1",[[5,"square_forest_roadA.gltf-001",["_name"],[0,["09RRAHhAtZH76lcK7ojAXt"]]],[1,["_lpos"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,-0.429,-1,-0.026]],[1,["_lrot"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[3,0,0.7090109453476893,0,0.7051974754472509]],[1,["_euler"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,0,90.309,0]]]],40]],[4,0,null,1,[3,"c1wgYlmNFUkrQDgA4ryQc6",-218,[8,"d71YgQwv9OmpI1p+CuUbuS",[[5,"square_forest_roadB.gltf-001",["_name"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]]],[1,["_lpos"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,5.554,-1,-0.067]],[1,["_lrot"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,0,-89.691,0]]]],41]],[4,0,null,1,[3,"c1wgYlmNFUkrQDgA4ryQc6",-219,[8,"b9tbIBilRPNKZhSdVdrU/W",[[5,"square_forest_roadB.gltf-002",["_name"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]]],[1,["_lpos"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,7.534,-1,-0.078]],[1,["_lrot"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,0,-89.691,0]]]],42]],[4,0,null,1,[3,"09RRAHhAtZH76lcK7ojAXt",-220,[8,"65FUiPsIpPTag56EG4QCXM",[[5,"square_forest_roadA.gltf-002",["_name"],[0,["09RRAHhAtZH76lcK7ojAXt"]]],[1,["_lpos"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,5.381,-1,1.925]],[1,["_lrot"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,0,-89.691,0]]]],43]],[4,0,null,1,[3,"09RRAHhAtZH76lcK7ojAXt",-221,[8,"edWPZXbAZMOLZu2ITc6vRV",[[5,"square_forest_roadA.gltf-003",["_name"],[0,["09RRAHhAtZH76lcK7ojAXt"]]],[1,["_lpos"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,9.527,-1,-0.089]],[1,["_lrot"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,0,-89.691,0]]]],44]],[4,0,null,1,[3,"ecvhzyc3FSDIfJ52i987+V",-222,[8,"c5Ku9xYB1GArJLLcKCUvCd",[[5,"square_forest.gltf",["_name"],[0,["ecvhzyc3FSDIfJ52i987+V"]]],[1,["_lpos"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,7.376,-1,1.914]],[1,["_lrot"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,0,-89.691,0]]]],45]],[4,0,null,1,[3,"ecvhzyc3FSDIfJ52i987+V",-223,[8,"5eJKSr8jRODqjKSh7J3OIm",[[5,"square_forest.gltf-001",["_name"],[0,["ecvhzyc3FSDIfJ52i987+V"]]],[1,["_lpos"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,9.556,-1,1.902]],[1,["_lrot"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,0,-89.691,0]],[1,["_lpos"],[0,["0cvYw5L/JYiKZMqj8gS0Yc"]],[1,0,0,0.311]]]],46]],[4,0,null,1,[3,"ecvhzyc3FSDIfJ52i987+V",-224,[8,"e1kx8Ulp5KgLI7lqTtNqDR",[[5,"square_forest.gltf-002",["_name"],[0,["ecvhzyc3FSDIfJ52i987+V"]]],[1,["_lpos"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,1.92,-1,1.943]],[1,["_lrot"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,0,-89.691,0]],[1,["_lpos"],[0,["0cvYw5L/JYiKZMqj8gS0Yc"]],[1,0,0,0.311]]]],47]],[4,0,null,1,[3,"ecvhzyc3FSDIfJ52i987+V",-225,[8,"ebo9jf07RGmKtA4i0zk/6v",[[5,"square_forest.gltf-003",["_name"],[0,["ecvhzyc3FSDIfJ52i987+V"]]],[1,["_lpos"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,-0.26,-1,1.955]],[1,["_lrot"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,0,-89.691,0]]]],48]],[4,0,null,1,[3,"ecvhzyc3FSDIfJ52i987+V",-226,[8,"06W6kbLg9Gvq95pQlQ/LHd",[[5,"square_forest.gltf-004",["_name"],[0,["ecvhzyc3FSDIfJ52i987+V"]]],[1,["_lpos"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,-0.281,-1,-1.973]],[1,["_lrot"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,0,-89.691,0]]]],49]],[4,0,null,1,[3,"ecvhzyc3FSDIfJ52i987+V",-227,[8,"f3vHnikUtLZK0vTnBJy5iW",[[5,"square_forest.gltf-005",["_name"],[0,["ecvhzyc3FSDIfJ52i987+V"]]],[1,["_lpos"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,1.899,-1,-1.984]],[1,["_lrot"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,0,-89.691,0]],[1,["_lpos"],[0,["0cvYw5L/JYiKZMqj8gS0Yc"]],[1,0,0,0.311]]]],50]],[4,0,null,1,[3,"ecvhzyc3FSDIfJ52i987+V",-228,[8,"bbB88NNbRDlrZelCSF4m1H",[[5,"square_forest.gltf-006",["_name"],[0,["ecvhzyc3FSDIfJ52i987+V"]]],[1,["_lpos"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,7.675,-1,-2.016]],[1,["_lrot"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,0,-89.691,0]],[1,["_lpos"],[0,["0cvYw5L/JYiKZMqj8gS0Yc"]],[1,0,0,0.311]]]],51]],[4,0,null,1,[3,"ecvhzyc3FSDIfJ52i987+V",-229,[8,"43tv/5SbdK65VaxpFSu7+2",[[5,"square_forest.gltf-007",["_name"],[0,["ecvhzyc3FSDIfJ52i987+V"]]],[1,["_lpos"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,5.495,-1,-2.004]],[1,["_lrot"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[3,0,-0.7051974754472508,0,0.7090109453476894]],[1,["_euler"],[0,["ecvhzyc3FSDIfJ52i987+V"]],[1,0,-89.691,0]]]],52]],[4,0,null,1,[3,"c1wgYlmNFUkrQDgA4ryQc6",-230,[8,"f0x8xyDfJGoLBWaqWzvcV9",[[5,"square_forest_roadB.gltf-003",["_name"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]]],[1,["_lpos"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,3.568,-1,1.921]],[1,["_lrot"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[3,0,0,0,1]],[1,["_euler"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,0,0,0]]]],53]],[4,0,null,1,[3,"c1wgYlmNFUkrQDgA4ryQc6",-231,[8,"edmNteQGdPWqLi2L4+33Zi",[[5,"square_forest_roadB.gltf-004",["_name"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]]],[1,["_lpos"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,3.568,-1,3.889]],[1,["_lrot"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[3,0,0,0,1]],[1,["_euler"],[0,["c1wgYlmNFUkrQDgA4ryQc6"]],[1,0,0,0]]]],54]],[4,0,null,1,[3,"09RRAHhAtZH76lcK7ojAXt",-232,[8,"671d1XmwdHZrUUDYbFOg3m",[[5,"square_forest_roadA.gltf-004",["_name"],[0,["09RRAHhAtZH76lcK7ojAXt"]]],[1,["_lpos"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,3.573,-1,5.887]],[1,["_lrot"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[3,0,1,0,6.123233995736766e-17]],[1,["_euler"],[0,["09RRAHhAtZH76lcK7ojAXt"]],[1,0,180,0]]]],55]],[4,0,{},2,[3,"35x6F9Xs9eGLbWcu6bAzTj",-233,[8,"f0wrFAAM9N86+CINNseA6U",[[5,"Water_bg",["_name"],[0,["35x6F9Xs9eGLbWcu6bAzTj"]]],[1,["_lpos"],[0,["35x6F9Xs9eGLbWcu6bAzTj"]],[1,33.922,-3.512,39.665]],[1,["_lrot"],[0,["35x6F9Xs9eGLbWcu6bAzTj"]],[3,0,0,0,1]],[1,["_euler"],[0,["35x6F9Xs9eGLbWcu6bAzTj"]],[1,0,0,0]],[1,["_lscale"],[0,["35x6F9Xs9eGLbWcu6bAzTj"]],[1,76.636,2,105.382]]]],56]],[4,0,{},2,[3,"3bOkID8IdRIpPtzTsDa0zJ",-234,[8,"24ljI3lgxOU55pjsVfW/UD",[[14,"Bridge",["_name"],27],[2,["_lpos"],27,[1,53.56,0,41.068]],[2,["_lrot"],27,[3,0,0.7071067811865475,0,0.7071067811865476]],[2,["_euler"],27,[1,0,90,0]],[1,["_lscale"],[0,["3bOkID8IdRIpPtzTsDa0zJ"]],[1,7,10,10]]]],57]],[4,0,{},2,[3,"3bOkID8IdRIpPtzTsDa0zJ",-235,[8,"f7GYj7S31Hbb4s70E6OcOA",[[14,"Bridge-001",["_name"],28],[2,["_lpos"],28,[1,-3.034,0,41.068]],[2,["_lrot"],28,[3,0,0.7071067811865475,0,0.7071067811865476]],[2,["_euler"],28,[1,0,90,0]],[1,["_lscale"],[0,["3bOkID8IdRIpPtzTsDa0zJ"]],[1,7,10,10]]]],58]],[4,0,{},2,[3,"44gpMHLDdZBJSLZ/87jJX2",-236,[8,"efH/uYsztKKaZKGHNK31nl",[[14,"treeA",["_name"],29],[2,["_lpos"],29,[1,23.516,-0.236,-7.761]],[2,["_lrot"],29,[3,0,0,0,1]],[2,["_euler"],29,[1,0,0,0]],[1,["_lscale"],[0,["44gpMHLDdZBJSLZ/87jJX2"]],[1,10,10,10]]]],59]],[4,0,{},2,[3,"026DiC+npYBqhs90Rl7PXo",-237,[8,"f4GYu98eBJOK+1YRN1s/y8",[[14,"treeB",["_name"],30],[2,["_lpos"],30,[1,27.544,-0.236,-6.98]],[2,["_lrot"],30,[3,0,0,0,1]],[2,["_euler"],30,[1,0,0,0]],[1,["_lscale"],[0,["026DiC+npYBqhs90Rl7PXo"]],[1,10,10,10]]]],60]],[4,0,{},2,[3,"a4K9bi/XBTr4e3gZlzYVtr",-238,[8,"b5EMBua3BB6JZE9ANCzrPa",[[14,"treeC",["_name"],31],[2,["_lpos"],31,[1,2.041,-0.236,-5.98]],[2,["_lrot"],31,[3,0,0,0,1]],[2,["_euler"],31,[1,0,0,0]],[1,["_lscale"],[0,["a4K9bi/XBTr4e3gZlzYVtr"]],[1,10,10,10]]]],61]],[4,0,{},2,[3,"44gpMHLDdZBJSLZ/87jJX2",-239,[8,"bfmz8jMOZD4au4pjW6sJpc",[[14,"treeA-001",["_name"],32],[2,["_lpos"],32,[1,60.79,-0.236,29.389]],[2,["_lrot"],32,[3,0,0,0,1]],[2,["_euler"],32,[1,0,0,0]],[1,["_lscale"],[0,["44gpMHLDdZBJSLZ/87jJX2"]],[1,10,10,10]]]],62]],[4,0,{},2,[3,"026DiC+npYBqhs90Rl7PXo",-240,[8,"69BBe8/uhFqKEJLofUBK4n",[[14,"treeB-001",["_name"],33],[2,["_lpos"],33,[1,58.996,-0.236,32.389]],[2,["_lrot"],33,[3,0,0,0,1]],[2,["_euler"],33,[1,0,0,0]],[1,["_lscale"],[0,["026DiC+npYBqhs90Rl7PXo"]],[1,10,10,10]]]],63]],[4,0,{},2,[3,"44gpMHLDdZBJSLZ/87jJX2",-241,[8,"7eqnnpTEJMzr1dKeXAPpfY",[[14,"treeA-002",["_name"],34],[2,["_lpos"],34,[1,-8.332,-0.236,29.389]],[2,["_lrot"],34,[3,0,0,0,1]],[2,["_euler"],34,[1,0,0,0]],[1,["_lscale"],[0,["44gpMHLDdZBJSLZ/87jJX2"]],[1,10,10,10]]]],64]],[4,0,{},2,[3,"026DiC+npYBqhs90Rl7PXo",-242,[8,"73Yd6QHs5Dg4m5W8U21xHX",[[14,"treeB-002",["_name"],35],[2,["_lpos"],35,[1,-10.126,-0.236,32.389]],[2,["_lrot"],35,[3,0,0,0,1]],[2,["_euler"],35,[1,0,0,0]],[1,["_lscale"],[0,["026DiC+npYBqhs90Rl7PXo"]],[1,10,10,10]]]],65]],[4,0,null,2,[3,"a0vP15IIpfAKdgSklTl1lQ",-243,[8,"4eYPqmzH9O1qjmE5T7oTsi",[[5,"RockA",["_name"],[0,["a0vP15IIpfAKdgSklTl1lQ"]]],[1,["_lpos"],[0,["a0vP15IIpfAKdgSklTl1lQ"]],[1,28.186,0,-5.41]],[1,["_lrot"],[0,["a0vP15IIpfAKdgSklTl1lQ"]],[3,0,0,0,1]],[1,["_euler"],[0,["a0vP15IIpfAKdgSklTl1lQ"]],[1,0,0,0]],[1,["_lscale"],[0,["a0vP15IIpfAKdgSklTl1lQ"]],[1,10,10,10]]]],66]],[4,0,null,2,[3,"5eAuWkKMRejop04tjMb5q/",-244,[8,"cdJFjw96VABqAcCI0vRTIN",[[5,"rockB",["_name"],[0,["5eAuWkKMRejop04tjMb5q/"]]],[1,["_lpos"],[0,["5eAuWkKMRejop04tjMb5q/"]],[1,-29.717,0,29.727]],[1,["_lrot"],[0,["5eAuWkKMRejop04tjMb5q/"]],[3,0,0.6801389238870722,0,0.7330832450777576]],[1,["_euler"],[0,["5eAuWkKMRejop04tjMb5q/"]],[1,0,85.70900000000003,0]],[1,["_lscale"],[0,["5eAuWkKMRejop04tjMb5q/"]],[1,10,10,10]]]],67]],[4,0,null,2,[3,"c6nN0Zi/FfTa0pFPzCfQDP",-245,[8,"e2BZ+SonVDhpknSJ1CecZX",[[14,"Hill",["_name"],13],[2,["_lpos"],13,[1,74.92,3.511,-34.967]],[2,["_lrot"],13,[3,0,0,0,1]],[2,["_euler"],13,[1,0,0,0]],[2,["_lscale"],13,[1,10,10,10]]]],68]],[4,0,null,2,[3,"a6s/76YylUDath8HJKWyRJ",-246,[8,"01NgPo8+tBAqatpldwQT0o",[[14,"Well",["_name"],14],[2,["_lpos"],14,[1,-11.201,0,-5.073]],[2,["_lrot"],14,[3,0,0,0,1]],[2,["_euler"],14,[1,0,0,0]],[2,["_lscale"],14,[1,10,10,10]],[1,["_lpos"],[0,["b4AMGLS5xRur6U13o74/DN"]],[1,1.859,0.031,-0.374]]]],69]],[4,0,null,2,[3,"5eAuWkKMRejop04tjMb5q/",-247,[8,"66bpodpelGoY7pqdaS7z1K",[[5,"rockB-001",["_name"],[0,["5eAuWkKMRejop04tjMb5q/"]]],[1,["_lpos"],[0,["5eAuWkKMRejop04tjMb5q/"]],[1,38.662,0,-40.789]],[1,["_lrot"],[0,["5eAuWkKMRejop04tjMb5q/"]],[3,0,0,0,1]],[1,["_euler"],[0,["5eAuWkKMRejop04tjMb5q/"]],[1,0,0,0]],[1,["_lscale"],[0,["5eAuWkKMRejop04tjMb5q/"]],[1,10,10,10]]]],70]],[4,0,null,2,[3,"a0vP15IIpfAKdgSklTl1lQ",-248,[8,"c2qtXC69ZHhI7h/2pHROWT",[[5,"RockA-001",["_name"],[0,["a0vP15IIpfAKdgSklTl1lQ"]]],[1,["_lpos"],[0,["a0vP15IIpfAKdgSklTl1lQ"]],[1,2.938,0,33.241]],[1,["_lrot"],[0,["a0vP15IIpfAKdgSklTl1lQ"]],[3,0,0,0,1]],[1,["_euler"],[0,["a0vP15IIpfAKdgSklTl1lQ"]],[1,0,0,0]],[1,["_lscale"],[0,["a0vP15IIpfAKdgSklTl1lQ"]],[1,10,10,10]]]],71]],[4,0,null,2,[3,"c6nN0Zi/FfTa0pFPzCfQDP",-249,[8,"aeLe7RUuBIkb91sbfl0zb+",[[5,"Hill-001",["_name"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]]],[1,["_lpos"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]],[1,103.738,5.744,4.634]],[1,["_lrot"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]],[3,0,0,0,1]],[1,["_euler"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]],[1,0,0,0]],[1,["_lscale"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]],[1,10,10,10]]]],72]],[4,0,null,2,[3,"c6nN0Zi/FfTa0pFPzCfQDP",-250,[8,"f7H5qtShlHrY8m+xRw64U2",[[5,"Hill-002",["_name"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]]],[1,["_lpos"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]],[1,48.622,0.125,-20.42]],[1,["_lrot"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]],[3,0,-0.781422463999712,0,0.6240023499608144]],[1,["_euler"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]],[1,0,-102.782,0]],[1,["_lscale"],[0,["c6nN0Zi/FfTa0pFPzCfQDP"]],[1,10,10,10]]]],73]],[4,0,{},8,[3,"c46/YsCPVOJYA4mWEpNYRx",-251,[8,"91myVePqtG0KG+96UPpwZe",[[14,"Land_0",["_name"],36],[2,["_lpos"],36,[1,9.603,0,8.438]],[2,["_lrot"],36,[3,0,0,0,1]],[2,["_euler"],36,[1,0,0,0]]]],74]],[4,0,{},8,[3,"c46/YsCPVOJYA4mWEpNYRx",-252,[8,"bfwJG1cB1JsqDtIpsuTqJP",[[14,"Land_1",["_name"],37],[2,["_lpos"],37,[1,26.184,0,8.438]],[2,["_lrot"],37,[3,0,0,0,1]],[2,["_euler"],37,[1,0,0,0]]]],75]],[4,0,{},8,[3,"c46/YsCPVOJYA4mWEpNYRx",-253,[8,"0cOQGT99RLW5hcRcUKrRdX",[[14,"Land_2",["_name"],38],[2,["_lpos"],38,[1,41.471,0,8.438]],[2,["_lrot"],38,[3,0,0,0,1]],[2,["_euler"],38,[1,0,0,0]]]],76]],[4,0,{},8,[3,"c46/YsCPVOJYA4mWEpNYRx",-254,[8,"67wpiUee9Mebraow+H4y3P",[[14,"Land_3",["_name"],39],[2,["_lpos"],39,[1,9.603,0,23.742]],[2,["_lrot"],39,[3,0,0,0,1]],[2,["_euler"],39,[1,0,0,0]]]],77]],[4,0,{},8,[3,"c46/YsCPVOJYA4mWEpNYRx",-255,[8,"cfjR9VaAVPqLMKA5JxjSfb",[[14,"Land_4",["_name"],40],[2,["_lpos"],40,[1,26.235,0,23.826]],[2,["_lrot"],40,[3,0,0,0,1]],[2,["_euler"],40,[1,0,0,0]]]],78]],[4,0,{},8,[3,"c46/YsCPVOJYA4mWEpNYRx",-256,[8,"d9qshyl1xEGLdPGS8K+Sls",[[14,"Land_5",["_name"],41],[2,["_lpos"],41,[1,41.669,0,23.879]],[2,["_lrot"],41,[3,0,0,0,1]],[2,["_euler"],41,[1,0,0,0]]]],79]],[18,"Background",33554432,3,[[13,-257,[5,500,100]],[19,1,0,-258,80]]],[18,"Label",33554432,15,[[13,-259,[5,10,50.4]],[24,"x",20,20,-260]]],[18,"Label",33554432,16,[[13,-261,[5,68.96,50.4]],[24,"Seed_1",20,20,-262]]],[18,"Label",33554432,17,[[13,-263,[5,68.96,50.4]],[24,"Seed_2",20,20,-264]]],[18,"Label",33554432,18,[[13,-265,[5,68.96,50.4]],[24,"Seed_3",20,20,-266]]],[18,"Label",33554432,19,[[13,-267,[5,68.96,50.4]],[24,"Seed_4",20,20,-268]]],[18,"Label",33554432,20,[[13,-269,[5,68.96,50.4]],[24,"Seed_5",20,20,-270]]],[18,"Background",33554432,4,[[13,-271,[5,320,100]],[19,1,0,-272,93]]],[18,"Label",33554432,21,[[13,-273,[5,10,50.4]],[24,"x",20,20,-274]]],[18,"Label",33554432,22,[[13,-275,[5,52.6,50.4]],[24,"Water",20,20,-276]]],[18,"Label",33554432,23,[[13,-277,[5,70.01,50.4]],[24,"Fertilize",20,20,-278]]],[18,"Label",33554432,24,[[13,-279,[5,48.91,50.4]],[24,"Move",20,20,-280]]],[52,"Light","c0y6F5f+pAvI805TdmxIjx",6,[[76,-281,[4,4293982975],[77]]],[3,0.23297264686499833,-0.539092222296439,-0.7928612962362254,-0.16270920872162165],[1,-111.458,-213.016,0.391]],[53,"Camera","c9DMICJLFO5IeO07EPon7U",6,[[78,0,20,14,1822425087,-282]],[1,-23.351,34.357,44.335],[3,-0.27781593346944056,-0.36497167621709875,-0.11507512748638375,0.8811195706053617],[1,-35,-45,0]],[26,"mountain-001",5,[[20,-283,[9],[9],10]],[1,4.623,0,-0.74],[3,0,-0.016353006147771024,0,0.9998662806545338],[1,1.266,1.248,1],[1,0,-1.874,0]],[26,"mountain-002",5,[[20,-284,[11],[9],12]],[1,2.389,0,-0.615],[3,0,-0.17507461040334038,0,0.9845551689936519],[1,2.243,2.243,2.243],[1,0,-20.166,0]],[26,"mountain-003",5,[[20,-285,[13],[9],14]],[1,7.589,0,-0.615],[3,0,-0.061449211593392665,0,0.9981102115470768],[1,2.243,2.243,2.243],[1,0,-7.046,0]],[26,"mountain-004",5,[[20,-286,[15],[9],16]],[1,10.025,0,-0.563],[3,0,-0.016353006147771024,0,0.9998662806545338],[1,1.266,1.248,1],[1,0,-1.874,0]],[26,"mountain-005",5,[[20,-287,[17],[9],18]],[1,12.469,-0.048,0.02],[3,0,0.427957379606462,0,0.9037989163748597],[1,2.243,2.785,2.243],[1,0,50.676,0]],[26,"mountain-006",5,[[20,-288,[19],[9],20]],[1,14.752,0.716,2.074],[3,0,-0.5291197624967087,0,0.8485471565773034],[1,2.243,2.243,2.243],[1,0,-63.892,0]],[26,"mountain-007",5,[[20,-289,[21],[9],22]],[1,15.759,0.716,5.181],[3,0,-0.8421937085674165,0,0.5391750710571304],[1,1.529,1.529,1.529],[1,0,-114.745,0]],[26,"mountain-008",5,[[20,-290,[23],[9],24]],[1,16.748,-0.399,8.101],[3,0,-0.6580194612714771,0,0.7530009220366167],[1,2.537,3.017,2.09],[1,0,-82.298,0]],[30,"forest-001",11,[[20,-291,[27,28],[9],29]],[1,-4.81,-0.123,-0.74],[1,0.697,0.697,0.697]],[30,"forest-002",11,[[20,-292,[30,31],[9],32]],[1,3.555,0.58,2.901],[1,1.04,1.08,0.936]],[30,"forest-003",11,[[20,-293,[33,34],[9],35]],[1,-7.535,-0.123,0.431],[1,0.697,0.697,0.697]],[59,"Camera",9,[-294],[1,0,0,1000]],[79,0,1073741824,320,2000,6,41943040,124,[4,4278190080]],[54,"GardenScene","22xmfpwIdFDojy+s70r/1w",6,[[80,-295,[102,103,104],105]]]],0,[0,-1,56,0,-2,57,0,-3,58,0,-4,59,0,-5,60,0,-6,61,0,-7,62,0,-8,63,0,-9,64,0,-10,65,0,-11,66,0,-12,67,0,-13,68,0,-14,69,0,-15,70,0,-16,71,0,-17,72,0,-18,73,0,-19,74,0,-1,75,0,-2,76,0,-3,77,0,-4,78,0,-5,79,0,-6,80,0,-7,81,0,-8,82,0,-9,83,0,-10,84,0,-11,85,0,-12,86,0,-13,87,0,-14,88,0,-15,89,0,-16,90,0,-17,91,0,-18,92,0,0,3,0,0,3,0,0,3,0,-1,99,0,-2,15,0,-3,16,0,-4,17,0,-5,18,0,-6,19,0,-7,20,0,0,4,0,0,4,0,0,4,0,-1,106,0,-2,21,0,-3,22,0,-4,23,0,-5,24,0,6,52,0,6,52,0,6,52,0,-1,113,0,-2,114,0,-3,115,0,-4,116,0,-5,117,0,-6,118,0,-7,119,0,-8,120,0,1,5,0,-1,42,0,-2,43,0,-3,44,0,-4,45,0,-5,46,0,-6,48,0,-7,49,0,-8,51,0,-10,53,0,-11,11,0,-12,55,0,-13,56,0,-14,57,0,-15,58,0,-16,59,0,-17,60,0,-18,61,0,-19,62,0,-20,63,0,-21,64,0,-22,65,0,-23,66,0,-24,67,0,-25,68,0,-26,69,0,-27,70,0,-28,71,0,-29,72,0,-30,73,0,-31,74,0,-32,75,0,-33,76,0,-34,77,0,-35,78,0,-36,79,0,-37,80,0,-38,81,0,-39,82,0,-40,83,0,-41,84,0,-42,85,0,-43,86,0,-44,87,0,-45,88,0,-46,89,0,-47,90,0,-48,91,0,-49,92,0,-50,93,0,-51,94,0,-52,95,0,-53,96,0,-54,97,0,-55,98,0,-1,111,0,-2,112,0,-3,12,0,-4,8,0,9,6,0,-6,9,0,-7,126,0,-1,42,0,-2,43,0,-3,44,0,-4,45,0,-5,46,0,-6,48,0,-7,49,0,-1,93,0,-2,94,0,-3,95,0,-4,96,0,-5,97,0,-6,98,0,0,9,0,12,125,0,0,9,0,0,9,0,-1,124,0,-1,51,0,-3,53,0,-4,11,0,-5,55,0,-1,121,0,-2,122,0,-3,123,0,1,11,0,0,15,0,0,15,0,0,15,0,-1,100,0,0,16,0,0,16,0,0,16,0,-1,101,0,0,17,0,0,17,0,0,17,0,-1,102,0,0,18,0,0,18,0,0,18,0,-1,103,0,0,19,0,0,19,0,0,19,0,-1,104,0,0,20,0,0,20,0,0,20,0,-1,105,0,0,21,0,0,21,0,0,21,0,-1,107,0,0,22,0,0,22,0,0,22,0,-1,108,0,0,23,0,0,23,0,0,23,0,-1,109,0,0,24,0,0,24,0,0,24,0,-1,110,0,1,42,0,1,43,0,1,44,0,1,45,0,6,47,0,6,47,0,6,47,0,1,46,0,1,48,0,6,50,0,6,50,0,6,50,0,1,49,0,1,51,0,6,54,0,6,54,0,6,54,0,1,53,0,1,55,0,1,56,0,1,57,0,1,58,0,1,59,0,1,60,0,1,61,0,1,62,0,1,63,0,1,64,0,1,65,0,1,66,0,1,67,0,1,68,0,1,69,0,1,70,0,1,71,0,1,72,0,1,73,0,1,74,0,1,75,0,1,76,0,1,77,0,1,78,0,1,79,0,1,80,0,1,81,0,1,82,0,1,83,0,1,84,0,1,85,0,1,86,0,1,87,0,1,88,0,1,89,0,1,90,0,1,91,0,1,92,0,1,93,0,1,94,0,1,95,0,1,96,0,1,97,0,1,98,0,0,99,0,0,99,0,0,100,0,0,100,0,0,101,0,0,101,0,0,102,0,0,102,0,0,103,0,0,103,0,0,104,0,0,104,0,0,105,0,0,105,0,0,106,0,0,106,0,0,107,0,0,107,0,0,108,0,0,108,0,0,109,0,0,109,0,0,110,0,0,110,0,0,111,0,0,112,0,0,113,0,0,114,0,0,115,0,0,116,0,0,117,0,0,118,0,0,119,0,0,120,0,0,121,0,0,122,0,0,123,0,-1,125,0,0,126,0,13,6,1,9,12,2,9,12,3,9,9,4,9,9,5,9,10,7,9,12,10,9,12,295],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,2,2,2,2,2,2,2,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,2,2,-1,-2,4,-1,-2,4,-1,-2,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,7,7,8,7,8,7,8,7,8,7,8,7,8,7,7,8,7,8,7,8,7,8,-1,-2,-3,14,15,16],[6,6,6,6,6,6,6,38,39,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,40,41,10,11,12,10,11,12,10,11,12,42,8,43,9,9,8,8,9,9,5,5,5,5,5,5,5,5,8,8,9,44,17,17,14,15,45,14,15,14,15,18,19,16,46,19,18,16,16,7,7,7,7,7,7,20,1,1,1,1,1,1,1,1,1,1,1,1,20,1,1,1,1,1,1,1,1,47,48,49,50,51,52]],[[{"name":"button","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[53]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.7029160857200623,0.4253237545490265,0.20689357817173004]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[21],[17,"square_forest_roadA",[-2],[6,"09RRAHhAtZH76lcK7ojAXt",-1,0]],[15,"square_forest_roadA",1,[[12,-3,[10,"cc1TKu7ApbqKFhQ/8Ug8fE"],[0,1],[9],2]],[6,"b4t5bgbKVTGpKH/ZhhbsOu",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[54,55,56]],[[[11,".bin",1906801784,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8208,"length":828,"count":414,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":9708,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":8208,"count":171,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":9036,"length":672,"count":14,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1,0,-1],"maxPosition",8,[1,1,0.9999996423721313,1]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.0653415098786354,0.5005427598953247,0.2656450867652893]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",3691527676,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16128,"length":1008,"count":504,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":135312,"length":12960,"count":6480,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":16128,"count":336,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":17136,"length":118176,"count":2462,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9777076840400696,-0.01863694190979004,-0.9737462997436523],"maxPosition",8,[1,0.9527628421783447,1.3415250778198242,0.9223982095718384]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.02141951024532318,0.25731161236763,0.26676133275032043]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[16,"forest.gltf"],[27,"forest.gltf",[-2],[6,"24Ys2U9jpV+qVYrD2vvkNf",-1,0],[1,60.058,0,-51.472],[1,15,15,15]],[31,"forest",1,[[12,-3,[10,"c1Vm5FtsVZRJEtCpV0O6dZ"],[0,1],[9],2]],[6,"4eFZUQ6GZRHbB4gO3OmK9S",1,0],[1,0,0,0.284]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[10,11,12]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.7029160857200623,0.4253237545490265,0.20689357817173004]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.1923278123140335,0.22819341719150543,0.24619518220424652]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.5778115391731262,0.23347531259059906,0.11534765362739563]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.799102783203125,0.799102783203125,0.799102783203125]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",3778961873,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2016,"length":384,"count":192,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":28032,"length":3324,"count":1662,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":32700,"length":96,"count":48,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":81516,"length":4800,"count":2400,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":96780,"length":1392,"count":696,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":2016,"count":42,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2400,"length":25632,"count":534,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":31356,"length":1344,"count":28,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":32796,"length":48720,"count":1015,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":86316,"length":10464,"count":218,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.8436157703399658,-0.008920181542634964,-0.8190275430679321],"maxPosition",8,[1,0.8436156511306763,0.9049292206764221,0.83721923828125]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.1923278123140335,0.22819341719150543,0.24619518220424652]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",1277819108,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16896,"length":1512,"count":756,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":16896,"count":352,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1,-0.5000000596046448,-0.37191569805145264],"maxPosition",8,[1,1,0.27688872814178467,0.3719162344932556]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":1,"USE_ALBEDO_MAP":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":2,"specularFactor":0},"mainColor",8,[4,4291480266],"specularColor",8,[4,4294177779],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[11,3],[57,13]],[[[11,".bin",543267915,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":10416,"length":912,"count":228,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":10416,"count":186,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.014293084852397442,-0.015204191207885742,-0.014089970849454403],"maxPosition",8,[1,0.012645578011870384,0.02955474518239498,0.011070724576711655]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",223032939,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5376,"length":654,"count":327,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":20478,"length":2820,"count":1410,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":5376,"count":112,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":6030,"length":14448,"count":301,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.24838916957378387,0,-0.1719273328781128],"maxPosition",8,[1,0.23835070431232452,0.7268149852752686,0.17192775011062622]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.02141951024532318,0.25731161236763,0.26676133275032043]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[16,"plant_00_2"],[17,"plant_00_2",[-2],[6,"c7uLxNmYpVHp/5NHQxYG9R",-1,0]],[32,"TB_Env_Grass_Med_C002",1,[[12,-3,[10,"bayS9J4d5ZyKvlDviVbx6g"],[0],[9],1]],[6,"1fLgbEwwhVdYg7b5LFJOfM",1,0],[1,86.2792739868164,86.27928161621094,86.2792739868164]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,4],[58,59]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.7029160857200623,0.4253237545490265,0.20689357817173004]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",1971926032,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":648,"count":324,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":39624,"length":1500,"count":750,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":5256,"length":34368,"count":716,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.736423671245575,-0.015901265665888786,-0.6415857076644897],"maxPosition",8,[1,0.736282467842102,0.2838388681411743,0.6415857076644897]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@e9a6d","back":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@40c10","left":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@8fd34","right":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@74afd","top":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@bb97f","bottom":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@7d38f"}]}],[6],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[16,"treeA"],[27,"treeA",[-2],[6,"44gpMHLDdZBJSLZ/87jJX2",-1,0],[1,-67,0,12],[1,10,10,10]],[15,"detail_treeA",1,[[12,-3,[10,"f7p5YGE/RfQoAbEXClWLyb"],[0,1],[9],2]],[6,"5aCeAEAHJShoU1iN/lEMxW",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[60,61,62]],[[[16,"farm_plot_null"],[33,"farm_plot_null",[-2],[6,"a3/CqMcipbNZWJptIpe6/F",-1,0],[1,9.361,-0.403,8.351],[3,0,0.7071067811865475,0,0.7071067811865476],[1,10,10,10],[1,0,90,0]],[15,"farm_plot",1,[[12,-3,[10,"a1RWhhznVfRrhgZTGNnBmD"],[0,1],[9],2]],[6,"6aRJkT3KFaOp7SHJ26xkQK",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[63,64,65]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.1923278123140335,0.22819341719150543,0.24619518220424652]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",1488995552,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":43200,"length":6612,"count":3306,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":43200,"count":900,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.934990644454956,-0.05062481015920639,-0.82896888256073],"maxPosition",8,[1,0.9572367668151855,0.5131850838661194,0.5014674663543701]]],-1],0,0,[],[],[]],[[[21],[17,"detail_rocks",[-2],[6,"5eAuWkKMRejop04tjMb5q/",-1,0]],[15,"detail_rocks",1,[[12,-3,[10,"d6OQFYJSRbQLwrLpBAv+iv"],[0],[9],1]],[6,"98gkRVmQJRZ7/mkXu8E1kr",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,4],[66,67]],[[[11,".bin",3652978587,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1,0,-1],"maxPosition",8,[1,1,0.9999996423721313,1]]],-1],0,0,[],[],[]],[[[21],[17,"square_forest",[-2],[6,"ecvhzyc3FSDIfJ52i987+V",-1,0]],[15,"square_forest",1,[[12,-3,[10,"2fxioZWCVUWJLZhERI/xKl"],[0],[9],1]],[6,"0cvYw5L/JYiKZMqj8gS0Yc",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,4],[68,69]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.0653415098786354,0.5005427598953247,0.2656450867652893]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[16,"plant_00_0"],[40,"plant_00_0",[-3],[[35,-2,[10,"26ivsm4H1FBIl7Q8CVyZwX"]]],[6,"b7rs69lF9Vg6yKogrhGmiJ",-1,0]],[32,"TB_Env_Grass_Med_C",1,[[12,-4,[10,"ccC9KVnZtXO5jxmkdZ6yqr"],[0],[9],1]],[6,"1bQ5U0KXNVoro3chFf3IEQ",1,0],[1,48.90214920043945,48.90214920043945,48.90214920043945]]],0,[0,1,1,0,0,1,0,-1,2,0,0,2,0,5,1,4],[0,0],[-1,4],[70,71]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",1472148743,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":108,"count":54,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":2796,"length":108,"count":54,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":28,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1452,"length":1344,"count":28,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1,0,-1],"maxPosition",8,[1,1,0.9999996423721313,1]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.0653415098786354,0.5005427598953247,0.2656450867652893]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.7029160857200623,0.4253237545490265,0.20689357817173004]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.0653415098786354,0.5005427598953247,0.2656450867652893]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[21],[17,"square_forest_roadE",[-2],[6,"4c3CK6N89Wmpkg1Y4EDSHY",-1,0]],[15,"square_forest_roadE",1,[[12,-3,[10,"f17CJJUpBY44DOxUdCjVth"],[0,1],[9],2]],[6,"56ZZH69w5ak5YXnrszBXgd",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[72,73,74]],[[[11,".bin",52014918,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":15600,"length":1512,"count":756,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":19032,"length":168,"count":84,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":15600,"count":325,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":17112,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1,0,-1.0000004768371582],"maxPosition",8,[1,1,1,1.0000003576278687]]],-1],0,0,[],[],[]],[[[16,"plant_00_1"],[17,"plant_00_1",[-2],[6,"83r8Hn+itVPZ/U6BslJcLI",-1,0]],[32,"TB_Env_Grass_Med_C001",1,[[12,-3,[10,"aaYfoLxE1S2KD1FIvqhhIk"],[0],[9],1]],[6,"e18EtAll5dqaDaC20ulJVy",1,0],[1,48.90214538574219,48.90214920043945,48.90214538574219]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,4],[75,76]],[[[16,"Land"],[17,"Land",[-12,-13],[61,"c46/YsCPVOJYA4mWEpNYRx",-11,0,[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]]],[55,"blocks",1,[-14,-15,-16,-17,-18,-19,-20,-21,-22],[6,"34UlZlfZ9JAonxQNwEVkgb",1,0],[1,0.157,0.2,0]],[4,0,null,2,[3,"047WPd4YhflLipehZ6gK4y",-25,[22,"f9gQIKpClP750zyAB56Hy4",1,[[1,["_lpos"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,-4,0.2,-4.338]],[5,"block_0",["_name"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lrot"],[0,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[1,["_euler"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[1,["_lscale"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[5,true,["_active"],[0,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],-23,[1,0,0,0]],[2,["_lscale"],-24,[1,1,1,1]]]],0]],[4,0,null,2,[3,"047WPd4YhflLipehZ6gK4y",-26,[22,"44bjZ4fIlKRpj1oq5Gnjid",1,[[1,["_lpos"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,-0.09,0.2,-4.338]],[5,"block_1",["_name"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lrot"],[0,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[1,["_euler"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[1,["_lscale"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[5,true,["_active"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lpos"],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,-0.002,0,0]],[1,["_lscale"],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,1,1,1]]]],1]],[4,0,null,2,[3,"047WPd4YhflLipehZ6gK4y",-29,[22,"a0FOOcjpRKMYmNdiq1Ouzs",1,[[1,["_lpos"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,3.742,0.2,-4.338]],[5,"block_2",["_name"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lrot"],[0,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[1,["_euler"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[1,["_lscale"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[5,true,["_active"],[0,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],-27,[1,0,0,0]],[2,["_lscale"],-28,[1,1,1,1]]]],2]],[4,0,null,2,[3,"047WPd4YhflLipehZ6gK4y",-32,[22,"20VyLy7ZlE9qpKWzSdjwSA",1,[[1,["_lpos"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,-4,0.2,-0.166]],[5,"block_3",["_name"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lrot"],[0,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[1,["_euler"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[1,["_lscale"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[5,true,["_active"],[0,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],-30,[1,0,0,0]],[2,["_lscale"],-31,[1,1,1,1]]]],3]],[4,0,null,2,[3,"047WPd4YhflLipehZ6gK4y",-33,[22,"8ca4RKGWBMKKuqZBugtGYD",1,[[1,["_lpos"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,-0.09,0.2,-0.166]],[5,"block_4",["_name"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lrot"],[0,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[1,["_euler"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[1,["_lscale"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[5,true,["_active"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lpos"],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,-0.002,0,0]],[1,["_lscale"],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,1,1,1]]]],4]],[4,0,null,2,[3,"047WPd4YhflLipehZ6gK4y",-34,[22,"c7KhTQHetB779S+5B4Mlbk",1,[[1,["_lpos"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,3.742,0.2,-0.166]],[5,"block_5",["_name"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lrot"],[0,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[1,["_euler"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[1,["_lscale"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[5,true,["_active"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lpos"],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,0,0,0]],[1,["_lscale"],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,1,1,1]]]],5]],[4,0,null,2,[3,"047WPd4YhflLipehZ6gK4y",-37,[22,"a9nIhan+5I2Ymbqlu4p77m",1,[[1,["_lpos"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,-4,0.2,3.847]],[5,"block_6",["_name"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lrot"],[0,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[1,["_euler"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[1,["_lscale"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[5,true,["_active"],[0,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],-35,[1,0,0,0]],[2,["_lscale"],-36,[1,1,1,1]]]],6]],[4,0,null,2,[3,"047WPd4YhflLipehZ6gK4y",-38,[22,"cbj5l0bbREL6P1VHH3uZBt",1,[[1,["_lpos"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,-0.09,0.2,3.847]],[5,"block_7",["_name"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lrot"],[0,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[1,["_euler"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[1,["_lscale"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[5,true,["_active"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lpos"],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,-0.002,0,0]],[1,["_lscale"],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[1,1,1,1]]]],7]],[4,0,null,2,[3,"047WPd4YhflLipehZ6gK4y",-41,[22,"aeUc3oTFlLGYutA1iYeFdq",1,[[1,["_lpos"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,3.742,0.2,3.847]],[5,"block_8",["_name"],[0,["047WPd4YhflLipehZ6gK4y"]]],[1,["_lrot"],[0,["047WPd4YhflLipehZ6gK4y"]],[3,0,0,0,1]],[1,["_euler"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,0,0,0]],[1,["_lscale"],[0,["047WPd4YhflLipehZ6gK4y"]],[1,10,10,10.90531]],[5,true,["_active"],[0,["047WPd4YhflLipehZ6gK4y"]]],[2,["_lpos"],-39,[1,0,0,0]],[2,["_lscale"],-40,[1,1,1,1]]]],8]],[4,0,{},1,[3,"a3/CqMcipbNZWJptIpe6/F",-42,[22,"4fV5cw7A9JPr8g1JqKJnM0",1,[[5,"Plane",["_name"],[0,["a3/CqMcipbNZWJptIpe6/F"]]],[1,["_lpos"],[0,["a3/CqMcipbNZWJptIpe6/F"]],[1,0,0,0]],[1,["_lrot"],[0,["a3/CqMcipbNZWJptIpe6/F"]],[3,0,0.7071067811865475,0,0.7071067811865476]],[1,["_euler"],[0,["a3/CqMcipbNZWJptIpe6/F"]],[1,0,90,0]],[1,["_lscale"],[0,["a3/CqMcipbNZWJptIpe6/F"]],[1,10,10,10]],[5,true,["_active"],[0,["a3/CqMcipbNZWJptIpe6/F"]]]]],9]],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[0,["4bxf/9yPpVMZGAn0aI9L/H"]],[0,["4bxf/9yPpVMZGAn0aI9L/H"]]],0,[0,-1,12,0,-2,11,0,-3,10,0,-4,9,0,-5,8,0,-6,7,0,-7,6,0,-8,5,0,-9,4,0,-10,3,0,1,1,0,-1,2,0,-2,12,0,-1,3,0,-2,4,0,-3,5,0,-4,6,0,-5,7,0,-6,8,0,-7,9,0,-8,10,0,-9,11,0,6,13,0,6,13,0,1,3,0,1,4,0,6,14,0,6,14,0,1,5,0,6,15,0,6,15,0,1,6,0,1,7,0,1,8,0,6,16,0,6,16,0,1,9,0,1,10,0,6,17,0,6,17,0,1,11,0,1,12,0,5,1,42],[0,0,0,0,0,0,0,0,0,0],[2,2,2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,4,4,77]],[[[16,"treeC"],[27,"treeC",[-2],[6,"a4K9bi/XBTr4e3gZlzYVtr",-1,0],[1,-65,0,16],[1,10,10,10]],[15,"detail_treeC",1,[[12,-3,[10,"18UXT8C0pduJ5nG3AfY/az"],[0,1],[9],2]],[6,"fc1dURISZbvY/4oolGx+8y",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[78,79,80]],[[[16,"Bridge"],[33,"Bridge",[-2],[6,"3bOkID8IdRIpPtzTsDa0zJ",-1,0],[1,53.56,0,41.068],[3,0,0.7071067811865475,0,0.7071067811865476],[1,7,10,10],[1,0,90,0]],[15,"bridge",1,[[12,-3,[10,"40YPvwEtxSU59ng4FeR5fO"],[0],[9],1]],[6,"06igxcX7xQaqjOKRnzwu2v",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,4],[81,82]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.1923278123140335,0.22819341719150543,0.24619518220424652]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.5778115391731262,0.23347531259059906,0.11534765362739563]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",161997575,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":12672,"length":1140,"count":570,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":17700,"length":318,"count":159,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":44034,"length":1740,"count":870,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":59310,"length":1656,"count":828,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":12672,"count":264,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":13812,"length":3888,"count":81,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":18018,"length":26016,"count":542,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":45774,"length":13536,"count":282,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.5845520496368408,-0.5818215608596802,-0.7601936459541321],"maxPosition",8,[1,0.9497389793395996,1.015300989151001,0.6601937413215637]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",2133637274,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":52608,"length":4776,"count":2388,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":52608,"count":1096,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.2996215522289276,-0.49747902154922485,-0.49747902154922485],"maxPosition",8,[1,0.22007349133491516,0.49747902154922485,0.49747902154922485]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.799102783203125,0.799102783203125,0.799102783203125]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[21],[17,"watermill",[-2],[6,"28/ZOZhUBWpIZ5IHsZ/JcR",-1,0]],[34,"watermill",1,[-4],[[12,-3,[10,"85K1ZEscJXiZDTI4KIVHS+"],[2,3,4,5],[9],6]],[6,"6aksB1jTVd5pGqNl4lDvpP",1,0]],[31,"watermill_wheel",2,[[12,-5,[10,"43ytuyGvdeWpa96TGUOjsS"],[0],[9],1]],[6,"851DM6jghT954gocAwrLxt",1,0],[1,-0.18682861328125,0,0]]],0,[0,1,1,0,-1,2,0,0,2,0,-1,3,0,0,3,0,5,1,5],[0,0,0,0,0,0,0],[-1,4,-1,-2,-3,-4,4],[21,83,84,85,21,86,87]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"DCC_APP_NAME":1,"USE_ALBEDO_MAP":true},{},{}],[[[{"emissiveScale":0,"shininessExponent":2,"specularFactor":0},"mainColor",8,[4,4291480266],"specularColor",8,[4,4294177779],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[11,3],[88,13]],[[[11,".bin",543267915,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":10416,"length":912,"count":228,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":10416,"count":186,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.014293084852397442,-0.015204191207885742,-0.014089970849454403],"maxPosition",8,[1,0.012645578011870384,0.02955474518239498,0.011070724576711655]]],-1],0,0,[],[],[]],[[{"name":"popup_panel","rect":{"x":0,"y":0,"width":20,"height":20},"offset":{"x":0,"y":0},"originalSize":{"width":20,"height":20},"rotated":false,"capInsets":[4,5,4,5],"vertices":{"rawPosition":[-10,-10,0,10,-10,0,-10,10,0,10,10,0],"indexes":[0,1,2,2,1,3],"uv":[0,20,20,20,0,0,20,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-10,"y":-10,"z":0},"maxPos":{"x":10,"y":10,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[10],[89]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.7029160857200623,0.4253237545490265,0.20689357817173004]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.1923278123140335,0.22819341719150543,0.24619518220424652]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.5778115391731262,0.23347531259059906,0.11534765362739563]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[21],[17,"well",[-2],[6,"a6s/76YylUDath8HJKWyRJ",-1,0]],[15,"well",1,[[12,-3,[10,"9dYAIiaQ5eEbRb4TUIxltA"],[0,1,2,3,4,5],[9],6]],[6,"b4AMGLS5xRur6U13o74/DN",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,4],[90,91,92,93,94,95,96]],[[[11,".bin",3742900158,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":18528,"length":2172,"count":1086,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":40476,"length":2424,"count":1212,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":62196,"length":1632,"count":816,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":73716,"length":984,"count":492,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":75660,"length":96,"count":48,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":76908,"length":204,"count":102,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":18528,"count":386,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":20700,"length":19776,"count":412,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":42900,"length":19296,"count":402,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":63828,"length":9888,"count":206,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":74700,"length":960,"count":20,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":75756,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.5089786648750305,-0.0017956208903342485,-0.5089786052703857],"maxPosition",8,[1,0.508978545665741,0.7348325848579407,0.5089786648750305]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.10092172026634216,0.11823292821645737,0.12790560722351074]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{"cullMode":0},"depthStencilState":{"depthWrite":false},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.13025973737239838,"metallic":0},"albedoScale",8,[1,0.06462205201387405,0.6740851402282715,0.7510285377502441]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@e9a6d","back":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@40c10","left":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@8fd34","right":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@74afd","top":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@bb97f","bottom":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@7d38f"}]}],[6],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[16,"mountain.gltf"],[27,"mountain.gltf",[-2],[6,"83SeZfoXpYxqDSeafSTC8H",-1,0],[1,-42.914,0,-63.589],[1,10,10,10]],[15,"mountain",1,[[12,-3,[10,"56cTGTam1TI7a9ATz3Obhp"],[0],[9],1]],[6,"bbj1vKpHBZEpe9sKTpmR43",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,4],[2,3]],[[[16,"treeB"],[27,"treeB",[-2],[6,"026DiC+npYBqhs90Rl7PXo",-1,0],[1,-61,0,15],[1,10,10,10]],[15,"detail_treeB",1,[[12,-3,[10,"60p5BD1GxWDpFqpOrqRIyo"],[0,1],[9],2]],[6,"f0/MCuEPxSELndQ1CyVBTC",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[97,98,99]],[[[16,"Plant"],[40,"Plant",[-4],[[81,-2,[10,"5eQjsUjKtEWYuUtsJcky+K"],[1,2]],[35,-3,[10,"6e/LuqlhtPFqToqDS3iUCP"]]],[6,"c46/YsCPVOJYA4mWEpNYRx",-1,0]],[34,"RenderRoot2D",1,[-7,-8],[[35,-5,[10,"edhYBaneJET5R/pAqZtnYt"]],[82,-6,[10,"dbP4fG+EZHLorwkdxA4jAN"]]],[6,"50inU5UR1DcbXaVD3bPzMC",1,0]],[56,"Label",33554432,2,[[42,-9,[10,"0aCMCmguVMRqE0POxRCS5k"],[5,66.17,50.4]],[75,"00:00:00",17,17,-10,[10,"2fPFCMFvVO159+juFhhUiv"]]],[6,"ccURRjhnFNVZgRMTDqHDmf",1,0]],[57,"StatusNode",33554432,2,[[42,-11,[10,"e7BfczfNlPn6Vqr0KBj2ws"],[5,119,119]],[74,-12,[10,"4cvh181TBDNJZv3HleYFko"],0]],[6,"7bAsEPMVdD3YxnywpRLJz+",1,0],[1,480,320,0],[1,0.2,0.2,0.2]]],0,[0,1,1,0,0,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,-1,3,0,-2,4,0,0,3,0,0,3,0,0,4,0,0,4,0,5,1,12],[0,0,0],[7,-1,-2],[22,100,22]],[[[16,"Water_bg"],[27,"Water_bg",[-2],[6,"35x6F9Xs9eGLbWcu6bAzTj",-1,0],[1,33.922,-3.512,39.665],[1,76.636,2,105.382]],[15,"square_water_detail",1,[[12,-3,[10,"04Ai/+BudY04B5Xvo7VHtO"],[0,1],[9],2]],[6,"27O0PFKzJarrlkEiuGeZ1u",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[101,102,103]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",1758442339,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6480,"length":702,"count":351,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":15438,"length":1320,"count":660,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6480,"count":135,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":7182,"length":8256,"count":172,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.27688834071159363,-0.000911755720153451,-0.17305736243724823],"maxPosition",8,[1,0.2587195932865143,0.7565363645553589,0.2486431747674942]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.02141951024532318,0.25731161236763,0.26676133275032043]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[16,"GrassTile"],[58,"GrassTile",[-2],[6,"8duwTerv1d7YHyRlQmUBl3",-1,0],[1,-1,0,27]],[15,"square_forest_detail",1,[[12,-3,[10,"5cvVvCnPtWEq/oBEqcqnMt"],[0,1],[9],2]],[6,"bdf/FJ+45d0KMa8iAOjOP+",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[104,105,106]],[[[83,"dcc/imported-specular-glossiness",[{"hash":2838361292,"name":"dcc/imported-specular-glossiness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_NORMAL_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVESCALE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":10,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":11,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":12,"defines":["CC_FORWARD_ADD"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_vertexId","format":11,"location":12,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * (In.tangent.w > 0.0 ? 1.0 : -1.0);\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin mediump float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    if (pcf > 2.9) {\n      return CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      return CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && layer < 0) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          layer = i;\n        }\n      }\n      return layer;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      vec4 csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n      vec4 shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(shadowPos, N, shadowBias);\n    }\n  #endif\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      if (cc_shadowLPNNInfo.w > 0.0) {\n        #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n          shadow = CCCSMFactorBase(position, N, s.shadowBias);\n        #endif\n      } else {\n        #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n          shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n        #endif\n      }\n    }\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec3 lightmap = s.lightmap.rgb;\n    #if CC_USE_HDR\n        lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n    #endif\n    vec3 finalColor = diffuse * lightmap.rgb * shadow;\n  #else\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n      vec3 env = GetEnvReflectionWithMipFiltering(rotationDir, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, rotationDir, s.roughness * (cc_ambientGround.w - 1.0));\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = LinearToSRGB(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = vec4(1.0);\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    texColor.a *= transparencyFactor;\n    baseColor *= texColor;\n  #else\n    baseColor *= diffuseColor;\n  #endif\n  baseColor.rgb *= diffuseFactor;\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n    #if DCC_APP_NAME == DCC_APP_MAYA\n      baseColor.a = 1.0 - baseColor.a;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < alphaThreshold) discard;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  vec4 specularColorAndFactor = getSpecularColorAndFactor();\n  float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n  #if HAS_EXPORTED_GLOSSINESS\n    #if USE_SPECULAR_GLOSSINESS_MAP\n      inGlossiness = 1.0 - texture(specularGlossinessMap, TEXTURE_UV).a;\n    #else\n      inGlossiness = glossiness;\n    #endif\n  #else\n    #if USE_SHININESS_MAP\n      #if USE_SHININESS_MAP_CHANNEL\n        inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).SHININESS_MAP_CHANNEL;\n      #else\n        inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n      #endif\n    #else\n      inGlossiness = convertShininessExponent(shininessExponent);\n    #endif\n    inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n  #endif\n  float inMetallic = 0.0;\n  vec4 albedo = baseColor;\n  #if HAS_EXPORTED_METALLIC\n    inMetallic = metallic;\n    float spec = specularFactor;\n    #if USE_SPECULAR_MAP\n      spec = dot(GRAY_VECTOR, texture(specularMap, TEXTURE_UV).rgb);\n    #endif\n    inSpecularIntensity *= spec * 0.5;\n  #else\n    GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n    inSpecularIntensity *= inMetallic;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalScale) * normalize(v_tangent) +\n      (nmmp.y * normalScale) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    packHighpData(s.position, s.position_fract_part, v_position);\n    #else\n    s.position = v_position;\n    #endif\n  s.albedo = albedo;\n  s.occlusion = 1.0;\n  s.roughness = 1.0 - inGlossiness;\n  s.metallic = inMetallic;\n  s.specularIntensity = inSpecularIntensity * 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW  && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCFragOutput(CCStandardShadingBase(s, v_shadowPos));\n    #if CC_USE_FOG != 4\n      CC_APPLY_FOG(color, s.position.xyz);\n    #endif\n    fragColorX = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * (In.tangent.w > 0.0 ? 1.0 : -1.0);\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_debug_view_mode;\n  uniform mediump vec4 cc_debug_view_composite_pack_1;\n  uniform mediump vec4 cc_debug_view_composite_pack_2;\n  uniform mediump vec4 cc_debug_view_composite_pack_3;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 diffuseColor;\n     uniform vec4 specularColor;\n     uniform vec4 emissive;\n     uniform float emissiveScale;\n     uniform float alphaThreshold;\n     uniform float shininessExponent;\n     uniform float glossiness;\n     uniform float metallic;\n     uniform float normalScale;\n     uniform float transparencyFactor;\n     uniform float diffuseFactor;\n     uniform float specularFactor;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    if (pcf > 2.9) {\n      return CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      return CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && layer < 0) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          layer = i;\n        }\n      }\n      return layer;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      vec4 csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n      vec4 shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(shadowPos, N, shadowBias);\n    }\n  #endif\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      if (cc_shadowLPNNInfo.w > 0.0) {\n        #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n          shadow = CCCSMFactorBase(position, N, s.shadowBias);\n        #endif\n      } else {\n        #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n          shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n        #endif\n      }\n    }\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec3 lightmap = s.lightmap.rgb;\n    #if CC_USE_HDR\n        lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n    #endif\n    vec3 finalColor = diffuse * lightmap.rgb * shadow;\n  #else\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n      vec3 env = GetEnvReflectionWithMipFiltering(rotationDir, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, rotationDir, s.roughness * (cc_ambientGround.w - 1.0));\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = LinearToSRGB(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture2D(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture2D(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = vec4(1.0);\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    texColor.a *= transparencyFactor;\n    baseColor *= texColor;\n  #else\n    baseColor *= diffuseColor;\n  #endif\n  baseColor.rgb *= diffuseFactor;\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n    #if DCC_APP_NAME == DCC_APP_MAYA\n      baseColor.a = 1.0 - baseColor.a;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < alphaThreshold) discard;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  vec4 specularColorAndFactor = getSpecularColorAndFactor();\n  float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n  #if HAS_EXPORTED_GLOSSINESS\n    #if USE_SPECULAR_GLOSSINESS_MAP\n      inGlossiness = 1.0 - texture2D(specularGlossinessMap, TEXTURE_UV).a;\n    #else\n      inGlossiness = glossiness;\n    #endif\n  #else\n    #if USE_SHININESS_MAP\n      #if USE_SHININESS_MAP_CHANNEL\n        inGlossiness = 1.0 - texture2D(shininessExponentMap, TEXTURE_UV).SHININESS_MAP_CHANNEL;\n      #else\n        inGlossiness = 1.0 - discolor(texture2D(shininessExponentMap, TEXTURE_UV).rgb);\n      #endif\n    #else\n      inGlossiness = convertShininessExponent(shininessExponent);\n    #endif\n    inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n  #endif\n  float inMetallic = 0.0;\n  vec4 albedo = baseColor;\n  #if HAS_EXPORTED_METALLIC\n    inMetallic = metallic;\n    float spec = specularFactor;\n    #if USE_SPECULAR_MAP\n      spec = dot(GRAY_VECTOR, texture2D(specularMap, TEXTURE_UV).rgb);\n    #endif\n    inSpecularIntensity *= spec * 0.5;\n  #else\n    GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n    inSpecularIntensity *= inMetallic;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalScale) * normalize(v_tangent) +\n      (nmmp.y * normalScale) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    packHighpData(s.position, s.position_fract_part, v_position);\n    #else\n    s.position = v_position;\n    #endif\n  s.albedo = albedo;\n  s.occlusion = 1.0;\n  s.roughness = 1.0 - inGlossiness;\n  s.metallic = inMetallic;\n  s.specularIntensity = inSpecularIntensity * 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW  && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCFragOutput(CCStandardShadingBase(s, v_shadowPos));\n    #if CC_USE_FOG != 4\n      CC_APPLY_FOG(color, s.position.xyz);\n    #endif\n    gl_FragData[0] = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":142,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":114}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"SHININESS_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"HAS_EXPORTED_GLOSSINESS","type":"boolean"},{"name":"USE_SHININESS_MAP_CHANNEL","type":"boolean"},{"name":"HAS_EXPORTED_METALLIC","type":"boolean"},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"}]},{"hash":2373376484,"name":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TRANSPARENCY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_vertexId","format":11,"location":12,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":13,"defines":[]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout highp vec2 v_clip_depth;\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n    mediump vec4 cc_debug_view_mode;\n    mediump vec4 cc_debug_view_composite_pack_1;\n    mediump vec4 cc_debug_view_composite_pack_2;\n    mediump vec4 cc_debug_view_composite_pack_3;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_surfaceTransform;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin highp vec2 v_clip_depth;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  #if USE_ALPHA_TEST\n    float alpha = diffuseColor.a;\n    #if USE_VERTEX_COLOR\n      alpha *= v_color.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha *= texture(albedoMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_TRANSPARENCY_MAP\n      alpha = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        alpha = 1.0 - alpha;\n      #endif\n    #endif\n    if (alpha < alphaThreshold) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 diffuseColor;\n   uniform float alphaThreshold;\n   uniform float transparencyFactor;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_LIGHTMAP_DISABLED 0\n#define CC_LIGHTMAP_ALL_IN_ONE 1\n#define CC_LIGHTMAP_CC_LIGHTMAP_INDIRECT_OCCLUSION 2\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  #if USE_ALPHA_TEST\n    float alpha = diffuseColor.a;\n    #if USE_VERTEX_COLOR\n      alpha *= v_color.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha *= texture2D(albedoMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_TRANSPARENCY_MAP\n      alpha = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        alpha = 1.0 - alpha;\n      #endif\n    #endif\n    if (alpha < alphaThreshold) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":57,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":114}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]],[[[16,"mill.gltf"],[33,"mill.gltf",[-2],[6,"dbiC/T3S5cFKURapLrUyWC",-1,0],[1,55.875,0,14.762],[3,0,-0.672670353094142,0,0.7399422923905636],[1,10,10,10],[1,0,-84.547,0]],[34,"mill",1,[-4],[[12,-3,[10,"1dLgTY6rhVaq1pi1bPq5mL"],[3,4,5,6,7],[9],8]],[6,"78pRGK07tazrm0PO/uVPkq",1,0]],[31,"mill_blades",2,[[12,-5,[10,"544/HxV/lSSZcFpErALKzn"],[0,1],[9],2]],[6,"0aeOsRRi5UYLgwPfUUhiGb",1,0],[1,0,1.2678406238555908,0.16987228393554688]]],0,[0,1,1,0,-1,2,0,0,2,0,-1,3,0,0,3,0,5,1,5],[0,0,0,0,0,0,0,0,0],[-1,-2,4,-1,-2,-3,-4,-5,4],[23,24,107,23,108,24,109,110,111]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.1923278123140335,0.22819341719150543,0.24619518220424652]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[21],[17,"detail_hill",[-2],[6,"c6nN0Zi/FfTa0pFPzCfQDP",-1,0]],[15,"detail_hill",1,[[12,-3,[10,"d2I2TuMFZaDbUkDhyVmOMt"],[0,1,2,3],[9],4]],[6,"aaJIYlpxRcVJim1F1rZATA",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0,0,0],[-1,-2,-3,-4,4],[112,113,114,115,116]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.0653415098786354,0.5005427598953247,0.2656450867652893]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",2121151343,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1152,"length":180,"count":90,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":19524,"length":2058,"count":1029,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":64830,"length":7368,"count":3684,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":78246,"length":456,"count":228,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1332,"length":18192,"count":379,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":21582,"length":43248,"count":901,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":72198,"length":6048,"count":126,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.9542747735977173,-0.002388477325439453,-0.81588214635849],"maxPosition",8,[1,0.8644835948944092,1.098442554473877,0.7729062438011169]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.02141951024532318,0.25731161236763,0.26676133275032043]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.5,"metallic":0},"albedoScale",8,[1,0.7029160857200623,0.4253237545490265,0.20689357817173004]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[21],[17,"square_forest_roadB",[-2],[6,"c1wgYlmNFUkrQDgA4ryQc6",-1,0]],[15,"square_forest_roadB",1,[[12,-3,[10,"96uRWIgBFZ9KVzVWs2TfhQ"],[0,1],[9],2]],[6,"158iMbjJVcDqskuafn1PZ1",1,0]]],0,[0,1,1,0,-1,2,0,0,2,0,5,1,3],[0,0,0],[-1,-2,4],[117,118,119]],[[[11,".bin",2344664510,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3552,"length":324,"count":162,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":4068,"length":12,"count":6,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":3552,"count":74,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":3876,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1,0,-1],"maxPosition",8,[1,1,0.9999996423721313,1]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.0653415098786354,0.5005427598953247,0.2656450867652893]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.32694560289382935,0.10152623057365417,0.05927089974284172]],{},{}],11,0,0]]],0,0,[0],[3],[0]],[[[11,".bin",552310120,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6144,"length":702,"count":351,"stride":2}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":12606,"length":1020,"count":510,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6144,"count":128,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":6846,"length":5760,"count":120,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.2724704444408417,-1.440661545615285e-8,-0.19510294497013092],"maxPosition",8,[1,0.3212660551071167,0.7803274989128113,0.19653400778770447]]],-1],0,0,[],[],[]],[[[7,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true},{},{}],[[[{"roughness":0.4000000059604645,"metallic":0},"albedoScale",8,[1,0.02141951024532318,0.25731161236763,0.26676133275032043]],{},{}],11,0,0]]],0,0,[0],[3],[0]]]]
